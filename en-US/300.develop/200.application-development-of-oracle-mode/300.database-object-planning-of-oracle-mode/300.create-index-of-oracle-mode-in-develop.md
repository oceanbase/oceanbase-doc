|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# Create an index

This topic describes how to create an index with some examples.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>This topic mainly introduces how to create indexes by using the <code>CREATE INDEX</code> statement. For other methods of creating indexes, see <a href="../../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/2400.create-table-of-oracle-mode.md">CREATE TABLE</a> or <a href="../../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1000.alter-table-of-oracle-mode.md">ALTER TABLE</a>.</p> 
</main>

## Overview

An index, also known as a secondary index, is an optional structure. OceanBase Database uses the clustered index table model. The system automatically generates a primary key index for the specified primary key, and other indexes that you create are secondary indexes. You can determine the fields on which indexes are to be created based on business needs to speed up queries on these fields.

For more information about indexes in OceanBase Database, see [About indexes](../../../700.reference/100.oceanbase-database-concepts/400.database-objects/100.database-objects-of-oracle-mode/300.index-of-oracle-mode/100.the-index-overview-of-oracle-mode.md).

## Prerequisites

Before you create an index, make sure that:

* You have deployed an OceanBase cluster and created an Oracle tenant. For more information about how to deploy an OceanBase cluster, see [Deployment overview](../../../400.deploy/100.deploy-overview.md).

* You have connected to the Oracle tenant of OceanBase Database. For more information about how to connect to OceanBase Database, see [Overview of connection methods](../100.connect-to-oceanbase-database-of-oracle-mode/100.connection-methods-overview-of-oracle-mode.md).

* You have created a table. For more information, see [Create a table](../300.database-object-planning-of-oracle-mode/200.create-table-of-oracle-mode-in-develop.md).

* You have the `INDEX` privilege and the `ALTER` privilege on the table on which an index is to be created. For more information about how to view your privileges, see [View user privileges](../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/300.permission-of-oracle-mode/600.view-user-permissions-of-oracle-mode.md). If you do not have the required privileges, contact the administrator to obtain the privileges. For more information, see [Grant direct privileges](../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/300.permission-of-oracle-mode/200.authority-of-oracle-mode.md).

## Limitations

* In OceanBase Database, the index name must be unique within the table.

* The length of the index name cannot exceed 128 bytes.

* Multiple unique indexes can be created on a table, but each unique index must ensure the uniqueness of the corresponding column values.

* If you want to use a local unique index to enforce data uniqueness, the local unique index must include the table partition key.

## Considerations

* We recommend that you use names that succinctly describe the columns covered by the index and its purpose, for example, `idx_customer_name`. For more information about naming conventions, see [Object naming conventions](../../../700.reference/400.database-design-specifications-and-practices/100.object-naming-conventions/100.overview-of-object-naming-conventions.md).

* If the partition rules for a global index are the same as those for the primary table and have the same number of partitions, we recommend that you create a local index.

* We recommend that you limit the number of SQL statements for parallel index creation to the maximum number of CPU cores specified in the tenant's unit specifications. For example, if the tenant's unit specification is 4 CPU cores (4C), it is recommended to have no more than 4 index creation statements executed concurrently.

* We recommend that you create indexes on fields that are frequently used for queries, but do not create excessive indexes on tables that are frequently updated.

* Do not create indexes on tables with a small amount of data. For a table with a small data amount, it may take a shorter time to query all the data than to traverse the indexes. In this case, indexes cannot produce optimization effects.

* If modification requirements are far more than retrieval requirements, do not create indexes.

* Create efficient indexes:

   * Indexes must be created on all the columns to be queried. This can reduce the number of rows returned from table access by index primary key.

   * Indexes of equivalent conditions should always be placed in the front of the index table.

   * Indexes for large data filtering and sorting should be placed in the front of the index table.

## Create an index by using a statement

You can use the [CREATE INDEX](../../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1600.create-index-of-oracle-mode.md) statement to create an index.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>You can use the <a href="../../../700.reference/700.system-views/500.system-view-of-oracle-mode/200.dictionary-view-of-oracle-mode/26800.user_indexes-of-oracle-mode.md">USER_INDEXES</a> view to query information about the indexes in the table.</p>
</main>

## Examples

### Example 1: Create a unique index

If there is a need to ensure that the values in an indexed column are unique, a `UNIQUE` index can be created.

Use the following SQL statements to create a table named `test_tbl1` and to create a unique index based on the `col2` column in `test_tbl1`.

1. Create a table named `test_tbl1`.

   ```sql
   CREATE TABLE test_tbl1(col1 NUMBER, col2 NUMBER, col3 VARCHAR2(50), PRIMARY KEY(col1));
   ```

2. Create a unique index named `idx_test_tbl1_col2` on the `col2` column in the `test_tbl1` table.

   ```sql
   CREATE UNIQUE INDEX idx_test_tbl1_col2 ON test_tbl1(col2);
   ```

3. Query indexes of the `test_tbl1` table.

   ```sql
   SELECT INDEX_NAME,INDEX_TYPE,TABLE_OWNER,TABLE_NAME,UNIQUENESS FROM user_indexes WHERE table_name='TEST_TBL1';
   ```

   The result is as follows:

   ```shell
   +---------------------------------+------------+-------------+------------+------------+
   | INDEX_NAME                      | INDEX_TYPE | TABLE_OWNER | TABLE_NAME | UNIQUENESS |
   +---------------------------------+------------+-------------+------------+------------+
   | TEST_TBL1_OBPK_1703316804944854 | NORMAL     | SYS         | TEST_TBL1  | UNIQUE     |
   | IDX_TEST_TBL1_COL2              | NORMAL     | SYS         | TEST_TBL1  | UNIQUE     |
   +---------------------------------+------------+-------------+------------+------------+
   2 rows in set
   ```

### Example 2: Create a non-unique index

Execute the following SQL statements to create a table named `test_tbl2` and create an index on the `col2` column in the `test_tbl2` table.

1. Create a table named `test_tbl2`.

   ```sql
   CREATE TABLE test_tbl2(col1 NUMBER, col2 NUMBER, col3 VARCHAR2(50), PRIMARY KEY(col1));
   ```

2. Create an index named `idx_test_tbl2_col2` on the `col2` column in the `test_tbl2` table.

   ```sql
   CREATE INDEX idx_test_tbl2_col2 ON test_tbl2(col2);
   ```

3. Query indexes of the `test_tbl2` table.

   ```sql
   SELECT INDEX_NAME,INDEX_TYPE,TABLE_OWNER,TABLE_NAME,UNIQUENESS FROM user_indexes WHERE table_name='TEST_TBL2';
   ```

   The result is as follows:

   ```shell
   +---------------------------------+------------+-------------+------------+------------+
   | INDEX_NAME               | INDEX_TYPE | TABLE_OWNER | TABLE_NAME | UNIQUENESS |
   +---------------------------------+------------+-------------+------------+------------+
   | TEST_TBL2_OBPK_1703317409002143 | NORMAL     | SYS         | TEST_TBL2  | UNIQUE     |
   | IDX_TEST_TBL2_COL2              | NORMAL     | SYS         | TEST_TBL2  | NONUNIQUE  |
   +---------------------------------+------------+-------------+------------+------------+
   2 rows in set
   ```

### Example 3: Create a local index

A local index is created on data in a single partition. The key-value pairs of the index and the data in the table are in a one-to-one match. Each index partition maps to one table partition. They share the same partitioning rules. Therefore, a local unique index is only guaranteed to be unique in a partition. Its uniqueness within the table is not guaranteed. The key word for creating a local index is `LOCAL`.

To use a local unique index as a unique constraint on a table, the local unique index must contain a partitioning key of the table.

Execute the following SQL statements to create a subpartitioned table named `tbl3_f_rl` and create a local unique index on the `col1` and `col2` columns in the `tbl3_f_rl` table.

1. Create a RANGE-LIST-subpartitioned table named `tbl3_f_rl` without using a template.

   ```sql
   CREATE TABLE tbl3_f_rl(col1 NUMBER,col2 NUMBER)
     PARTITION BY RANGE(col1)
       SUBPARTITION BY LIST(col2)
     (PARTITION p0 VALUES LESS THAN(100)
       (SUBPARTITION sp0 VALUES(1,3),
        SUBPARTITION sp1 VALUES(4,6),
        SUBPARTITION sp2 VALUES(7,9)),
      PARTITION p1 VALUES LESS THAN(200)
       (SUBPARTITION sp3 VALUES(1,3),
        SUBPARTITION sp4 VALUES(4,6),
        SUBPARTITION sp5 VALUES(7,9))
      );
   ```

2. Create an index named `idx_tbl3_f_rl_col1_col2` on the `col1` and `col2` columns in the `tbl3_f_rl` table.

   ```sql
   CREATE UNIQUE INDEX idx_tbl3_f_rl_col1_col2 ON tbl3_f_rl(col1,col2) LOCAL;
   ```

3. Query indexes of the `tbl3_f_rl` table.

   ```sql
   SELECT INDEX_NAME,INDEX_TYPE,TABLE_OWNER,TABLE_NAME,UNIQUENESS FROM user_indexes WHERE table_name='TBL3_F_RL';
   ```

   The result is as follows:

   ```shell
   +-------------------------+------------+-------------+------------+------------+
   | INDEX_NAME              | INDEX_TYPE | TABLE_OWNER | TABLE_NAME | UNIQUENESS |
   +-------------------------+------------+-------------+------------+------------+
   | IDX_TBL3_F_RL_COL1_COL2 | NORMAL     | SYS         | TBL3_F_RL  | UNIQUE     |
   +-------------------------+------------+-------------+------------+------------+
   1 row in set
   ```

### Example 4: Create a global index

The keyword for creating a global index is `GLOBAL`. Unlike a local index, the partitioning of a global index is independent of the partitioning of the table. You can specify the partitioning rules and the number of partitions for a global index. These rules and this number do not have to be the same as those of the table.

* If you do not specify the LOCAL or GLOBAL attribute for an index, OceanBase Database in Oracle mode defines this index as a `GLOBAL` index, and the index table has only one partition.

* The partitioning rules of a global index are not necessarily the same as those of the table.

* If a global index has the same partitioning rules and the same number of partitions as the table, we recommend that you create a local index in this case.  The reasons are twofold. First, global indexes cost higher to maintain. Second, the physical storage location of a table and a global index are not necessarily the same, unless you manually include them in the same table group.

Execute the following SQL statements to create a partitioned table named `tbl4_h` and create a global index on the `col2` column in the `tbl4_h` table.

1. Create a HASH-partitioned table named `tbl4_h`.

   ```sql
   CREATE TABLE tbl4_h(col1 NUMBER PRIMARY KEY,col2 NUMBER)
     PARTITION BY HASH(col1) PARTITIONS 5;
   ```

2. Create a RANGE-partitioned global index named `idx_tbl4_h_col2` on the `col2` column in the `tbl4_h` table.

   ```sql
   CREATE INDEX idx_tbl4_h_col2 ON tbl4_h(col2) GLOBAL
     PARTITION BY RANGE(col2)
      (PARTITION p0 VALUES LESS THAN(100),
       PARTITION p1 VALUES LESS THAN(200),
       PARTITION p2 VALUES LESS THAN(300)
      );
   ```

3. Query indexes of the `tbl4_h` table.

   ```sql
   SELECT INDEX_NAME,INDEX_TYPE,TABLE_OWNER,TABLE_NAME,UNIQUENESS FROM user_indexes WHERE table_name='TBL4_H';
   ```

   The result is as follows:

   ```shell
   +------------------------------+------------+-------------+------------+------------+
   | INDEX_NAME                   | INDEX_TYPE | TABLE_OWNER | TABLE_NAME | UNIQUENESS |
   +------------------------------+------------+-------------+------------+------------+
   | TBL4_H_OBPK_1703321659273683 | NORMAL     | SYS         | TBL4_H     | UNIQUE     |
   | IDX_TBL4_H_COL2              | NORMAL     | SYS         | TBL4_H     | NONUNIQUE  |
   +------------------------------+------------+-------------+------------+------------+
   2 rows in set
   ```

### Example 5: Create a function-based index

A function-based index is created based on the result of any function applied to a column or multiple columns. Function-based indexing is an optimization technique. You can use function-based indexes to quickly locate function values that match query conditions. This avoids repeated calculation and improves query efficiency.

OceanBase Database in Oracle mode imposes limitations on expressions of function-based indexes. Specifically, the expressions of some system functions cannot be used as function-based indexes. For more information about the relevant functions, see [System functions supported for function-based indexes](../../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/400.manage-indexes-of-oracle-mode/500.function-index-list-of-supported-functions-of-oracle-mode.md) and [System functions not supported for function-based indexes](../../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/400.manage-indexes-of-oracle-mode/600.function-index-list-of-not-supported-functions-of-oracle-mode.md).

Execute the following SQL statements to create a table named `test_tbl5` and create a function-based index on the `id` column in the `test_tbl5` table.

1. Create a table named `test_tbl5`.

   ```sql
   CREATE TABLE test_tbl5(id NUMBER, name VARCHAR2(18));
   ```

2. Create an index named `idx_test_tbl5_id` on the `id` column in the `test_tbl5` table.

   ```sql
   CREATE INDEX dx_test_tbl5_id ON test_tbl5 ((id+1));
   ```

3. Query the created function-based index.

   ```sql
   SELECT INDEX_NAME,INDEX_TYPE,TABLE_OWNER,TABLE_NAME,UNIQUENESS FROM user_indexes WHERE table_name='TEST_TBL5';
   ```

   The result is as follows:

   ```shell
   +-----------------+-----------------------+-------------+------------+------------+
   | INDEX_NAME      | INDEX_TYPE            | TABLE_OWNER | TABLE_NAME | UNIQUENESS |
   +-----------------+-----------------------+-------------+------------+------------+
   | DX_TEST_TBL5_ID | FUNCTION-BASED NORMAL | SYS         | TEST_TBL5  | NONUNIQUE  |
   +-----------------+-----------------------+-------------+------------+------------+
   1 row in set
   ```

## What to do next

After creating an index, you may need to optimize query performance. For more information on SQL tuning, see [SQL tuning](../../../700.reference/1000.performance-tuning-guide/500.sql-optimization/400.sql-optimization/100.overview-of-sql-optimization.md).

## References

* For more information about how to query indexes, see [Query indexes](../../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/400.manage-indexes-of-oracle-mode/300.view-indexes-of-oracle-mode.md).
* For more information about how to manage indexes, see [DROP INDEX](../../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/3200.drop-index-of-oracle-mode.md) and [Drop an index](../../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/1000.ddl-function-of-oracle-mode/200.index-operations-of-oracle-mode.md).
* For more information about unique and non-unique indexes, see [Unique and non-unique indexes](../../../700.reference/100.oceanbase-database-concepts/400.database-objects/100.database-objects-of-oracle-mode/300.index-of-oracle-mode/300.unique-and-non-unique-indexes-of-oracle-mode.md).
* For more information about local and global indexes, see [Local and global indexes](../../../700.reference/100.oceanbase-database-concepts/400.database-objects/100.database-objects-of-oracle-mode/300.index-of-oracle-mode/200.local-and-global-indexes-of-oracle-mode.md).