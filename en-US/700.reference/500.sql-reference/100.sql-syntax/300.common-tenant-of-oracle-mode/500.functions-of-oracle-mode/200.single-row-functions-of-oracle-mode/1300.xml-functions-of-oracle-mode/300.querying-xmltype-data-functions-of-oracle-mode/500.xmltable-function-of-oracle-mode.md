| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |

# XMLTABLE

## Purpose

`XMLTABLE()` maps the result returned based on an XPath into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. 

`XMLTABLE()` provides the following key features:

* Data extraction: You can specify an XPath expression in `XMLTABLE()` to accurately extract the desired parts of data from a complex XML document. 

* Data structuring: `XMLTABLE()` can map specific parts of XML data to relational rows and columns and thereby convert semi-structured XML data into structured tabular form, making SQL queries and analysis easier. 

* Table conversion: You can use structured data generated by `XMLTABLE()` to create virtual tables and use these table data to generate new tables or views for further processing in the database. 

## Syntax

```sql
XMLTABLE( [ XMLnamespaces_clause , ] XQuery_string XMLTABLE_options )

XMLnamespaces_clause:
 XMLNAMESPACES( { string AS identifier } | { DEFAULT string } [, { string AS identifier } | { DEFAULT string } ]...)

XMLTABLE_options:
  [ XML_passing_clause ]
  [ COLUMNS XML_table_column [, XML_table_column]...]

XML_passing_clause:
  PASSING [ BY VALUE ] expr [ AS identifier ]

XML_table_column:
  column { FOR ORDINALITY
          | { datatype | XMLTYPE } [ PATH string ] [ DEFAULT expr ]
  }
```

## Parameters

| **Parameter** | **Description** |
| -------- | -------- |
| XMLnamespaces_clause | The namespace prefix and URI for referencing an element or attribute with a namespace in XML queries. The clause contains a set of XML namespace declarations that are referenced by the XPath expression in the `PATH` clause of `XML_table_column`. The expression evaluates the columns of the entire `XMLTable()` function. If you want to use qualified names in the `PATH` expressions of the `COLUMNS` clause, you need to specify this clause.  |
| XQuery_string | The XQuery expression that selects data to be converted from the XML data. XQuery is an XML query language for extracting data from XML documents and implementing complex query operations. This parameter allows you to use the XQuery syntax to define instructions that specify elements or attributes to be extracted from the XML data. <main id="notice" type='notice'><h4>Notice</h4><p>The current version of OceanBase Database does not support XQuery. </p></main> |
| XML_passing_clause | Specifies the XML data to be passed to the XQuery expression by using the PASSING keyword. You can configure to pass the XML data by value or reference. The details are as follows:<ul><li>`PASSING`: marks the beginning of `XML_passing_clause`. The content of the `PASSING` clause is the input to `XMLTABLE()`. </li><li>`BY VALUE`: specifies to pass data by value, instead of by reference. This keyword is optional. In most cases, this option can be omitted because passing by value is the default behavior. </li><li>`expr`: an expression that returns an `XMLType` instance or an instance of a SQL scalar data type. The result of the expression is the XML data to be passed to the XQuery expression. This expression is usually a column name, variable, or more complex expression that returns `XMLType` data. In the current version of OceanBase Database, you can specify only one `expr` in the `PASSING` clause. </li><li>`AS identifier`: the alias (or identifier) of `expr`, which is optional. In an XQuery expression, you can use this alias to reference the passed data.  |
| COLUMNS | Defines the columns of the virtual table to be created by `XMLTable()`. This clause is optional.  If you omit the `COLUMNS` clause, `XMLTable()` returns a row with a single `XMLType` pseudocolumn named `COLUMN_VALUE`.  |
| XML_table_column | Defines a table column to be generated, which can be a column of a common data type or an `XMLType` column. You can also specify the XPath and default value for the column. `FOR ORDINALITY` is used to generate row numbers. The details are as follows: <ul><li>`FOR ORDINALITY`: specifies that this column is to be a column of generated row numbers. There must be at most one `FOR ORDINALITY` clause. It is created as a `NUMBER` column. </li><li> `datatype` or `XMLTYPE`: For each resulting column except the `FOR ORDINALITY` column, you must specify the column data type, which can be `XMLType` or any other data type. If the column data type is `XMLType`, you must specify the `XMLTYPE` clause. Returning the `XMLType` data by reference lets you specify other columns whose paths target nodes in the source data that are outside those targeted by the `PATH` expression for column. If the column data type is any other data type, then specify `datatype`. <ul><li>`PATH string`: specifies that the portion of the XQuery result that is addressed by XQuery expression string is to be used as the column content. This clause is optional. If you omit `PATH`, the XQuery expression column is assumed, for example, <code>XMLTable(... COLUMNS xyz)</code>. </li><li>`DEFAULT expr`: specifies the value to use when the `PATH` expression results in an empty sequence. This clause is optional. Its `expr` is an XQuery expression that is evaluated to produce the default value. </li></ul></li></ul> |

## Return type

The return type depends on the data type of the column specified in the `XMLTable()` function. 

## Examples

Call `XMLTABLE()` to convert XML data into an SQL table with columns of the employee ID, name, position, and salary. The details are as follows:

1. Define the default namespace `http://www.example.com/employees` to match the namespace in the XML data. 
2. Define the XQuery expression `'/employees/employee'` to select all `employee` elements. 
3. Specify the `PASSING` clause to pass the XML document to the XQuery expression. This example uses the `XMLTYPE()` constructor to encapsulate the entire XML document. `XMLTYPE()` converts XML data in the string form into `XMLType` data that the database can process. 
4. In the `COLUMNS` clause, define four columns that hold the data extracted from the XML document. The mappings are as follows:

   * The `employee_id` column is mapped to `emp_id` under each `employee` element. 
   * The `employee_name` column is mapped to `name` under each `employee` element. 
   * The `position` column is mapped to `position` under each `employee` element. 
   * The `salary` column is mapped to `salary` under each `employee` element. 

   The `PATH` clause after each column defines where to extract the corresponding values. 

```shell
SELECT *
FROM XMLTABLE(
       XMLNAMESPACES(DEFAULT 'http://www.example.com/employees'),
       '/employees/employee'
       PASSING XMLTYPE('
          <employees xmlns="http://www.example.com/employees">
               <employee>
                    <emp_id>1</emp_id>
                    <name>John Doe</name>
                    <position>Developer</position>
                    <salary>5000</salary>
               </employee>
               <employee>
                    <emp_id>2</emp_id>
                    <name>Jane Smith</name>
                    <position>Manager</position>
                    <salary>6500</salary>
               </employee>
          </employees>'
     )
     COLUMNS
          employee_id    INT           PATH 'emp_id',
          employee_name  VARCHAR2(100) PATH 'name',
          position       VARCHAR2(50)  PATH 'position',
          salary         NUMBER        PATH 'salary'
) AS emp_tab;
```

The return result is as follows:

```shell
+-------------+---------------+-----------+--------+
| EMPLOYEE_ID | EMPLOYEE_NAME | POSITION  | SALARY |
+-------------+---------------+-----------+--------+
|           1 | John Doe      | Developer |   5000 |
|           2 | Jane Smith    | Manager   |   6500 |
+-------------+---------------+-----------+--------+
2 rows in set
```
