| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# SELECT INTO

## Purpose

You can use this statement to store the query results in a variable or file.  

* `SELECT ... INTO OUTFILE` stores the result set in an external file in the specified output format.

* `SELECT ... INTO DUMPFILE` writes a single line without any format to an external file.

* `SELECT ... INTO var_list` stores the result set in variables.

## Required privileges

To execute the `SELECT INTO` statement, you must have the `FILE` privilege and the `SELECT` privilege on the corresponding table. For more information about privileges in OceanBase Database, see [Privilege types in MySQL mode](../../../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/200.permission-of-mysql-mode/100.permission-classification-of-mysql.md).

Here is an example:

Grant the `FILE` privilege to a user. You can use the following command:

```sql
GRANT FILE ON *.* TO user_name;
```

Here, `user_name` is the username of the account that executes the `SELECT INTO` statement.

## Syntax

```sql
select_stmt INTO
    {OUTFILE 'file_name' [ {CHARSET | CHARACTER SET} charset_name] [field_opt] [line_opt] [file_opt]
    | DUMPFILE 'file_name'
    | into_var_list}
;

field_opt:
    {COLUMNS | FIELDS} field_term_list

field_term_list:
  field_term [, field_term ...]

field_term:
    {[OPTIONALLY] ENCLOSED | TERMINATED | ESCAPED} BY string

line_opt:
    LINES line_term_list

line_term_list:
    line_term [, line_term ...]

line_term:
    {STARTING | TERMINATED} BY string

file_opt:
    file_option [, file_option ...]

file_option:
    SINGLE [=] {TRUE | FALSE}
    | MAX_FILE_SIZE [=] {int | string}
```

## Parameters

| Parameter | Description |
|------------------------|-----------|
| select_stmt | The query statement to be executed. `select_stmt` must return a result set. For more information about the structure and options of the query statement, see [SELECT](8100.select-of-mysql-mode/100.select-of-mysql-mode.md).  <main id="notice" type='explain'> <h4>Note</h4><p>The <code>INTO</code> clause can also be placed before <code>FROM</code>, for example, <code>SELECT * INTO OUTFILE '/home/admin/test_data/test_tbl1.csv' FROM test_tbl1 WHERE id > 5;</code>. </p></main> |
| file_name | The path and file name of the exported file. `file_name` can be in either of the following formats:<ul><li><code>/\$PATH/\$FILENAME</code>: stores the exported file on an OBServer node. </li><li><code>oss://\$PATH/\$FILENAME/?host=\$HOST&access_id=\$ACCESS_ID&access_key=\$ACCESSKEY</code>: stores the exported file in OSS. </li></ul> The options in the formats are described as follows:<ul><li><code>\$PATH</code>: the path for storing the exported file.  <ul><li>If the data is exported to an OBServer node, this parameter specifies the file path on the OBServer node. </li><li>If the data is exported to OSS, this parameter specifies the file path in a bucket. </li></ul> </li><li><code>\$FILENAME</code>: the name of the exported file. When <code>SINGLE = FALSE</code>, the parameter specifies the prefix in the name of exported files. If the parameter is not specified, the default prefix <code>data</code> is used. The suffix is automatically generated by the system. </li><li><code>\$HOST</code>: the host name or CDN domain name of the OSS service, that is, the address of the OSS service to be accessed. </li><li><code>\$ACCESS_ID</code>: the AccessKey ID required for authentication when accessing the OSS service. </li><li><code>\$ACCESSKEY</code>: the AccessKey secret required for authentication when accessing the OSS service. </li></ul> <main id="notice" type='explain'><h4>Note</h4><p>Alibaba Cloud OSS does not support files larger than 5 GB. When you export a file larger than 5 GB to Alibaba Cloud OSS, it is split into multiple smaller files. </p></main> |
| CHARSET \| CHARACTER SET charset_name | Optional. The character set of the exported file. `charset_name` specifies the name of the character set.  |
| field_opt | Optional. The field format options for the exported file. You can use the `FIELDS` or `COLUMNS` clause to specify the format of each field in the output file. For more information, see [field_term](#field_term).  |
| line_opt | Optional. The start and end character options for exported data rows. `LINES` specifies the characters to enclose each line in the output file. For more information, see [line_term](#line_term).  |
| file_opt | Optional. Specifies whether to export data as multiple files, and if so, the maximum size of each single file. For more information, see [file_option](#file_option).  |

### field_term

* `[OPTIONALLY] ENCLOSED BY string`: the characters for enclosing field values. By default, the field values are not enclosed by any characters. For example, `ENCLOSED BY '"'` specifies that character values are enclosed within a pair of double quotation marks (""). If the `OPTIONALLY` keyword is used, only values of the string type are enclosed within the specified symbols.
* `TERMINATED BY string`: the separator between field values. For example, `TERMINATED BY ','` specifies that field values are separated with commas (,).
* `ESCAPED BY string`: the escape character, which is used to process special characters or parse data in special formats. The backslash (\\) is the default escape character.

### line_term

* `STARTING BY string`: the character to start each line. By default, the character is not specified.
* `TERMINATED BY string`: the character to end each line. The default value is a line feed. For example, `... LINES TERMINATED BY '\n' ...` specifies that a row ends with a line feed.

### file_option

* `SINGLE [=] {TRUE | FALSE}`: specifies whether to export data as a single file or multiple files.

   * `SINGLE [=] TRUE`: exports data as a single file. This is the default value.
   * `SINGLE [=] FALSE`: exports data as multiple files.

    <main id="notice" type='notice'>
      <h4>Notice</h4>
      <p>When the degree of parallelism (DOP) is greater than 1 and <code>SINGLE = FALSE</code>, you can export data as multiple files to achieve parallel reading and writing for a higher export speed. </p>
    </main>

* `MAX_FILE_SIZE [=] {int | string}`: the maximum size of a single file when `SINGLE = FALSE`.

## Examples

1. Set a path for the exported file.

   To export a file, you need to set the system variable `secure_file_priv` to configure the path that can be accessed for export.

    <main id="notice" type='notice'>
      <h4>Notice</h4>
      <p>For security reasons, when you set the system variable <code>secure_file_priv</code>, you can connect to the database only through a local socket to execute the SQL statement that modifies the global variable. For more information, see <a href="../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/12000.secure_file_priv-global.md">secure_file_priv</a>. </p>
    </main>

   1. Log on to the OBServer node to connect to.

      ```bash
      ssh admin@xxx.xxx.xxx.xxx
      ```

   2. Execute the following statement to connect to the `mysql001` tenant through a local Unix Socket:

      ```bash
      obclient -S /home/admin/oceanbase/run/sql.sock -uroot@mysql001 -p******
      ```

   3. Set the path for the exported file to `/home/admin/test_data`.

      ```sql
      SET GLOBAL secure_file_priv = "/home/admin/test_data";
      ```

   4. Log out of the database.

2. Reconnect to the database and execute the `SELECT INTO OUTFILE` statement to export data. Specify to separate two field values with a comma (,), enclose a field value of the string type in double quotation marks (`"`), and end each line with a line feed.

   * Write a single file serially and specify the file name as `test_tbl1.csv`.

      ```sql
      SELECT /*+parallel(2)*/ * FROM test_tbl1
      INTO OUTFILE '/home/admin/test_data/test_tbl1.csv'
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        LINES TERMINATED BY '\n';
      ```

      The return result is as follows:

      ```shell
      Query OK, 9 rows affected
      ```

   * Write multiple files in parallel without specifying the file name prefix. That is, the file names use the default prefix `data`. Set the maximum size of each file to 4 MB.

      ```sql
      SELECT /*+parallel(2)*/ * FROM test_tbl1
        INTO OUTFILE '/home/admin/test_data/'
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        LINES TERMINATED BY '\n'
        SINGLE = FALSE MAX_FILE_SIZE = '4MB';
      ```

      The return result is as follows:

      ```shell
      Query OK, 9 rows affected
      ```

   * Write multiple files in parallel. Set the prefix of the file names to `dd2024` and the maximum size of each file to 4 MB.

      ```sql
      SELECT /*+parallel(2)*/ * FROM test_tbl1
        INTO OUTFILE '/home/admin/test_data/dd2024'
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        LINES TERMINATED BY '\n'
        SINGLE = FALSE MAX_FILE_SIZE = '4MB';
      ```

      The return result is as follows:

      ```shell
      Query OK, 9 rows affected
      ```

    <main id="notice" type='explain'>
      <h4>Note</h4>
      <p><ul><li>When multiple export tasks with the same destination path are executed at the same time, errors may occur or only part of the data may be exported. Therefore, you need to plan the export paths reasonably. </br>Here is an example:</br>When <code>SELECT /*+parallel(2)*/ * FROM t1 INTO OUTFILE 'test/data' SINGLE = FALSE;</code> and <code>SELECT /*+parallel(2)*/ * FROM t2 INTO OUTFILE 'test/data' SINGLE = FALSE;</code> are executed at the same time, an error may be reported due to the same export file name. In this case, we recommend that you set the export paths to <code>test/data1</code> and <code>test/data2</code> respectively. </li><li>When <code>SINGLE = FALSE</code> and the export task fails due to reasons such as <code>file already exist</code>, you can clear all files with the same file name prefix as the exported files in the export directory, or delete the export directory and create a new one, and then perform the export operation again. </br>Here is an example:</br>When the execution of <code>SELECT /*+parallel(2)*/ * FROM t1 INTO OUTFILE 'test/data' SINGLE = FALSE;</code> fails, you can delete all files with the file name prefix <code>data</code> under the <code>test</code> directory, or delete the <code>test</code> directory and create it again, and then try the export operation again. </li></ul></p>
    </main>

3. Log on to the server where the OBServer node resides and check the exported files under the directory `/home/admin/test_data` of the node.

    ```shell
    [xxx@xxx /home/admin/test_data]# ls
    ```

    The return result is as follows:

    ```shell
    data_0_0_0  data_0_1_0  dd2024_0_0_0  dd2024_0_1_0  test_tbl1.csv
    ```

    Here, `test_tbl1.csv` is the serially exported single file. `data_0_0_0` and `data_0_1_0` are the parallelly exported files without a specified file name prefix. `dd2024_0_0_0` and `dd2024_0_1_0` are the parallelly exported files with the specified file name prefix `dd2024`.

## References

[Export data by using OUTFILE statements](../../../../../500.data-migration/1000.use-sql-statements-migrate-data/300.use-outfile-statements-to-migrate-data.md)
