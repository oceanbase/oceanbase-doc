| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |


# CREATE TRIGGER

You can use the `CREATE TRIGGER` statement to create or replace a database trigger.

When specified conditions are met, the database automatically runs the trigger.

  <main id="notice" >
    <h4>Applicability</h4>
    <p>This topic applies only to OceanBase Database Enterprise Edition. OceanBase Database Community Edition provides only the MySQL mode. </p>
  </main>

## Prerequisites

To create a trigger in your own schema or in a table of your own schema, you must have the `CREATE TRIGGER` system privilege.

To create a trigger in the schema (`schema.SCHEMA`) of other users, you must have the `CREATE ANY TRIGGER` system privilege.

If a trigger is used to execute an SQL statement or call a stored procedure or function, the owner of the trigger must have the privileges required to perform these operations. These privileges must be granted to the owner directly rather than through roles.

## Syntax

The syntax of `create_trigger` is as follows:

```sql
CREATE [ OR REPLACE ]
TRIGGER plsql_trigger_source
```



The following shows more details:

* The syntax of `plsql_trigger_source` is as follows:

   ```sql
   [schema.] trigger_name
     { simple_dml_trigger
      | instead_of_dml_trigger
      | trigger_ordering_clause
    }
   ```



* The syntax of `simple_dml_trigger` is as follows:

   ```sql
   { BEFORE | AFTER } dml_event_clause [ referencing_clause ] [ FOR EACH ROW ]
   [ ENABLE | DISABLE ] [ WHEN ( condition ) ] trigger_body
   ```



* The syntax of `instead_of_dml_trigger` is as follows:

   ```sql
   INSTEAD OF { DELETE | INSERT | UPDATE } [ OR { DELETE | INSERT | UPDATE } ]...
   ON [ schema. ] view
   [ referencing_clause ] [ FOR EACH ROW ]
   [ ENABLE | DISABLE ] trigger_body
   ```

* The syntax of `trigger_ordering_clause` is as follows:

   ```sql
   { FOLLOWS | PRECEDES } [ schmema.] trigger_name [ , [ schmema.] trigger_name ]...
   ```

* The syntax of `dml_event_clause` is as follows:

   ```sql
   { DELETE | INSERT | UPDATE [ OF column [, column ]... ] }
   [ OR { DELETE | INSERT | UPDATE [ OF column [, column]... ] }...]
   ON [ schema.] { table | view }
   ```



* The syntax of `referencing_clause` is as follows:

   ```sql
   REFERENCING
   { OLD [ AS ] old
   | NEW [ AS ] new
   | PARENT [ AS ] parent
   }..
   ```



* The syntax of `trigger_body` is as follows:

   ```sql
   { plsql_block | CALL routine_clause }
   ```






## Semantics



| Syntax | Keyword or syntax node | Description |
|------------------------|-------------------------|--------------------------------------------------------|
| create_trigger | OR REPLACE | Re-creates this trigger (if any) and recompiles it.  Before the trigger is redefined, users granted the access privilege can still access this trigger without the need to obtain the access privilege again.  |
| create_trigger         | trigger_name                 | The name of the trigger to be created.  |
| plsql_trigger_source | schema | The name of the schema where the trigger is located. The default value is your schema.  |
| plsql_trigger_source   | simple_dml_trigger                  | Creates a simple DML trigger.     |
| plsql_trigger_source   | instead_of_dml_trigger              | Creates an `INSTEAD OF` DML trigger. `INSTEAD OF` triggers can read `:OLD` and `:NEW` values, but cannot modify `:OLD` and `:NEW` values.     |
| plsql_trigger_source   | trigger_ordering_clause             | Specifies the firing order of triggers with the same timing point. The specified triggers must exist and have been successfully compiled, but they do not need to be enabled.  |
| simple_dml_trigger | BEFORE | Enables the database to fire the trigger before a trigger event occurs. A row-level trigger will fire before the corresponding row is modified.  In a statement-level `BEFORE` trigger, the trigger body cannot read the `:NEW` or `:OLD` field. However, in a row-level `BEFORE` trigger, the trigger body can read and write the `:OLD` and `:NEW` fields. |
| simple_dml_trigger | AFTER | Enables the database to fire the trigger after a trigger event occurs. A row-level trigger will fire each time a row is modified.  In a statement-level `AFTER` trigger, the trigger body cannot read the `:NEW` or `:OLD` field. However, in a row-level `AFTER` trigger, the trigger body can read and write the `:OLD` and `:NEW` fields. |
| simple_dml_trigger | FOR EACH ROW | Creates the trigger as a row-level trigger.  When the optional trigger constraint defined in the `WHEN` condition is met, the database fires the row-level trigger.  If this clause is ignored, the trigger is a statement-level trigger. If the optional trigger constraint is met, the database fires the trigger as a statement-level trigger only when a trigger statement is executed.  |
| simple_dml_trigger | \[ ENABLE \| DISABLE \] | Creates a trigger that is in the enabled or disabled state. By default, a trigger in the enabled state is created. Creating a trigger that is in the disabled state ensures that the trigger can be correctly compiled before it is enabled.  |
| simple_dml_trigger | WHEN (condition) | An SQL condition. The database evaluates each row affected by the trigger statement. If the `condition` value of an affected row is `TRUE`, `trigger_body` runs in this row. Otherwise, `trigger_body` does not run in this row.  The trigger statement will run regardless of the condition value. In the `condition` statement, do not place a semicolon (:) prior to `NEW`, `OLD`, or `PARENT`.  If `WHEN (condition)` is specified, `FOR EACH ROW` must also be specified. `condition` must not contain subqueries or PL expressions, such as calls to user-defined functions.  |
| simple_dml_trigger     | trigger_body        | The PL block or `CALL` subroutine that the database uses to fire the trigger. The `CALL` subroutine is a PL subprogram wrapped in a PL package. If the `trigger_body` is a PL block and contains errors, the `CREATE [OR REPLACE]` statement will fail. |
| simple_dml_trigger     | dml_event_clause        | Defines the conditions for triggering DML events in the trigger. DML events include insert (INSERT), update (UPDATE), and delete (DELETE) operations. |
| instead_of_dml_trigger | view | The name of the view on which the trigger is to be created.  |
| instead_of_dml_trigger | FOR EACH ROW | Creates the `INSTEAD OF` trigger as a row-level trigger.  |
| instead_of_dml_trigger | \[ ENABLE \| DISABLE \] | Enables or disables the trigger. The default value is ENABLE. Creating the trigger in a disabled state ensures that the trigger is enabled only after it compiles correctly.   |
| instead_of_dml_trigger |  DELETE                 | If the trigger is created on a view, it fires whenever a `DELETE` statement removes a row from the table defined by the view.   |
| instead_of_dml_trigger | INSERT                 | If the trigger is created on a view, the database fires the trigger whenever an `INSERT` statement adds a row to the table defined by the view.   |
| instead_of_dml_trigger | UPDATE                 | If the trigger is created on a view, the database fires the trigger whenever an `UPDATE` statement changes the value of a column in the table defined by the view.   |
| instead_of_dml_trigger | schema                  | The name of the schema where the trigger resides. The default value is the current user's schema.   |
| instead_of_dml_trigger | trigger_body                 | The PL block or `CALL` subroutine that the database uses to fire the trigger. The `CALL` subroutine is a PL subprogram wrapped in a PL package. If the `trigger_body` is a PL block and contains errors, the `CREATE [OR REPLACE]` statement will fail.   |
| trigger_ordering_clause | / | Specifies the firing order of triggers with the same timing point. The specified triggers must exist and have been successfully compiled, but they do not need to be enabled.    |
| trigger_ordering_clause | FOLLOWS  | Indicates that the trigger being created must fire after the specified trigger.|
| trigger_ordering_clause | PRECEDES | Indicates that the trigger being created must fire before the specified trigger.|


## Examples

Example 1: Create a DML trigger named `del_new_region`.

```shell
CREATE OR REPLACE TRIGGER del_new_region
      BEFORE DELETE ON regions
      FOR EACH ROW
      WHEN (old.region_id >3)
   BEGIN
      INSERT INTO reg_his(region_id , region_name )
           VALUES( :old.region_id, :old.region_name );
   END;
 /
```

Example 2: Create a trigger named `tri2_t`, which fires after another trigger named `tri1_t`.

```shell
CREATE SEQUENCE seq_tri INCREMENT BY 1 START WITH 1 NOMAXVALUE MINVALUE 0 NOCYCLE NOCACHE;
CREATE TABLE t(c1 INT, c2 INT);
CREATE TABLE msg (c1 INT PRIMARY KEY, c2 VARCHAR(100));
CREATE OR REPLACE TRIGGER tri1_t BEFORE INSERT ON t FOR EACH ROW
BEGIN
  INSERT INTO msg VALUES (seq_tri.NEXTVAL, 'BEFORE INSERT tri1_t');
END;
/

CREATE OR REPLACE TRIGGER tri2_t BEFORE INSERT ON t FOR EACH ROW FOLLOWS tri1_t
BEGIN
  INSERT INTO msg VALUES (seq_tri.nextval, 'BEFORE INSERT tri2_t');
END;
/

INSERT INTO t VALUES (1, 1);

obclient> SELECT * FROM msg;
+----+----------------------+
| C1 | C2                   |
+----+----------------------+
|  1 | BEFORE INSERT tri1_t |
|  2 | BEFORE INSERT tri2_t |
+----+----------------------+
2 rows in set
```