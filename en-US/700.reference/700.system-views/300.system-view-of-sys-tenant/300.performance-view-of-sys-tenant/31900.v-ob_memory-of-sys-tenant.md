|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# V$OB_MEMORY

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>The view name is changed from <code>V$MEMORY</code> to <code>V$OB_MEMORY</code> since OceanBase Database V4.0.0. </p>
</main>

## Purpose

The `V$OB_MEMORY` view displays the tenant-level memory statistics.

## Columns

| **Column** | **Type** | **Nullable?** | **Description** |
|-------------|---------------|----------------|--------------------------------|
| TENANT_ID | bigint(20) | NO | The ID of the tenant. |
| SVR_IP | varchar(46) | NO | The IP address of the OBServer node. |
| SVR_PORT | bigint(20) | NO | The port number of the OBServer node. |
| CTX_NAME | varchar(256) | NO | The name of the context to which the memory belongs. |
| MOD_NAME | varchar(256) | NO | The name of the module to which the memory belongs. |
| COUNT | decimal(20,0) | NO | The difference between memory spaces that are allocated and released, which is the number of memory units used by the module. |
| HOLD | decimal(20,0) | NO | The size of memory currently occupied by the module. |
| USED | decimal(20,0) | NO | The size in bytes of memory being used by the module. |

### Values of the CTX_NAME column

The following table describes the common memory context names.

| CTX_NAME | Description |
|----------|------|
| DEFAULT_CTX_ID | The context ID of unallocated memory. |
| MEMSTORE_CTX_ID | The MemTable data context ID. |
| TRANS_CTX_MGR_ID | The transaction context ID. |
| PLAN_CACHE_CTX_ID | The context ID of the plan cache. |
| GLIBC | The memory applied for by using the Glibc Malloc API. |
| CO_STACK | The memory for the execution stack of threads. |
| KVSTORE_CACHE_ID | The ID of the auto-scaling cache. |
| META_OBJ_CTX_ID | The memory that stores metadata, such as metadata of macroblocks. |
| TX_CALLBACK_CTX_ID | The ID of the transaction callback context. This context records some modifications made during transaction execution so that the required data can be located when the transaction is committed or rolled back. |
| LOB_CTX_ID | The allocator ID in ObLobManager. |
| PS_CACHE_CTX_ID | The cache ID of the `PREPARE stmt_name FROM preparable_stmt` statement. |
| TX_DATA_TABLE | The transaction data table. This table stores the status of committed or rolled back transactions and is used in scenarios such as minor compaction of status information of uncommitted transactions and fast commits. |
| MDS_DATA_ID | The memory ID of multi-source data. |
| LIBEASY | The network framework memory (EASY). |
| LOGGER_CTX_ID | The context ID of the memory for application logs. |
| RPC_CTX_ID | The context ID of the memory for the RPC framework. |
| PKT_NIO | The network framework memory (pkt_nio). |
| SCHEMA_SERVICE | The memory for schema metadata, such as tables and databases. |

### Mappings between CTX_NAME and MOD_NAME

The following table lists the mappings between CTX_NAME and MOD_NAME.

<table>
  <thead>
    <tr>
      <th>CTX_NAME</th>
      <th>MOD_NAME</th>
      <th>TENANT</th>
    </tr>
  </thead>  
  <tr>
    <td rowspan="2">DEFAULT_CTX_ID</td>
    <td>
    <ul>
    <li>MysqlRequesReco: the module for recording MySQL requests.  </li>
    <li>LogAggreBuffer: the buffer module for log aggregation. </li>
    <li>PartitLogServic: the partition log service module. </li>
    <li>SqlDtl: the SQL details module. </li>
    <li>TransAudit: the transaction audit module. </li>
    <li>IoControl: the input/output control module. </li>
    <li>ResultSet: the module where result sets are located. </li>
    </ul>
    </td>
    <td>ALL</td>
  </tr>
  <tr>
    <td>
    <ul>
    <li>SchemaSysCache: the system-level cache module that caches mode information. </li>
    <li>SeArray: the array sorting module. </li>
    <li>SstaMicrBlocAll: the module for storing statistics and microblocks. </li>
    <li>CsSstableReader: the compressed table reader. </li>
    <li>TmpBlockManager: the temporary block manager. </li>
    <li>TenantSchemMgr: the tenant mode manager. </li>
    <li>DecoderCtx: the decoder context. </li>
    <li>SqlSqcHandler: the SQL semantics handler. </li>
    </ul>
    </td>
    <td>500 </td>
  </tr>
  <tr>
    <td>SQL_EXEC_CTX_ID </td>
    <td>
    <ul>
    <li>CostBasedRewrit: the cost-based rewrite optimizer.  </li>
    <li>SqlExecutor: the SQL executor. </li>
    <li>SqlPsCache: the SQL parameter cache module. </li>
    <li>OB_SQL_AGGR_FUNC_ROW: a row object for SQL aggregate functions. </li>
    </ul>
    </td>
    <td rowspan="6">ALL </td>
  </tr>
  <tr>
    <td>WORK_AREA</td>
    <td>
    <ul>
    <li>SqlAggrFuncRow: a row object for SQL aggregate functions.  </li>
    <li>WindowAggProc: the window aggregation processing module. </li>
    <li>SqLWindoRowStor: the module related to rows in the storage window. </li>
    <li>SqLChunkRowStor: the module related to rows in storage blocks. </li>
    <li>SqLTempTabLeRow: the module related to rows in temporary tables. </li>
    <li>ConnectByPump: the data transmission module for connections. </li>
    <li>SqlSortRow: the row sorting module. </li>
    <li>SortOpRows: the row object collection sorting module. </li>
    <li>SqLHashDisRowSt: the module for storing hash-distributed rows. </li>
    <li>SqLHashDist: the hash distribution module. </li>
    <li>HashNodeGrouRow: the grouping and row dividing module for hash nodes. </li>
    <li>HashDistinctOp: the hash deduplication module. </li>
    <li>ArenaHashJoin: the memory space management module for hash joins. </li>
    <li>HtOpAlloc: the hash table operation allocation module. </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>PLAN_CACHE_CTX_ID</td>
    <td>
    <ul>
    <li>OB_SQL_PHY_PLAN: the execution plan module.  </li>
    <li>OB_SQL_PLAN_CACHE: the module that caches execution plans. </li>
    <li>OB_SQL_PHY_PL_OBJ: the execution plan object module. </li>
    <li>PRE_CALC_EXPR: the module related to precomputation expressions. </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>TRANS_CTX_MGR_ID</td>
    <td>
    <ul>
    <li>PartTranCtxMgr: the partition transaction context. </li>
    <li>TenantCtxAlloca: the tenant allocation context. </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>TX_CALLBACK_CTX_ID</td>
    <td>MemtableCallbac: the module related to callbacks of memory tables.</td>
  </tr>
  <tr>
    <td>REPLAY_STATUS_CTX_ID</td>
    <td>ReplayStatus: the module related to the replay status.</td>
  </tr>
  <tr>
    <td>CO_STACK</td>
    <td>CO_STACK: the module related to the coroutine stack.</td>
    <td rowspan="3">500</td>
  </tr>
  <tr>
    <td>STORAGE_LONG_TERM_META_CTX_ID</td>
    <td>
    <ul>
    <li>Partition: a partition object.  </li>
    <li>PartitioStore: the partition store module. </li>
    <li>PartitioStorage: the partition storage. </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>STORAGE_SHORT_TERM_META_CTX_ID</td>
    <td>
    <ul>
    <li>Sstable: an SSTable.  </li>
    <li>SstableMeta: the SSTable of a meta tenant. </li>
    <li>MemtableObject: the memory table object. </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>ALL</td>
    <td>OB_COMMON_ARRAY: the common array in OceanBase Database.</td>
    <td>ALL</td>
  </tr>
</table>

### Impact of common SQL operations on the memory context

In OceanBase Database, each SQL execution or operation corresponds to a context. The memory usage varies based on the memory context used, depending on the data volume and operation complexity.
The following general SQL executions or operations may cause the increase in memory usage of some contexts.

* Sorting of a large amount of data by using the `ORDER BY` or `GROUP BY` clause: A sorting operation needs to load the data to the memory for sorting. This may cause an increase in the memory usage of `PLAN_CACHE_CTX_ID`, `MEMSTORE_CTX_ID`, and `DEFAULT_CTX_ID`.

* Aggregation of a large amount of data by using the `SUM`, `AVG`, `MAX`, or `MIN` function: An aggregation operation needs to load the data to the memory for computing. This may cause an increase in the memory usage of `PLAN_CACHE_CTX_ID`, `MEMSTORE_CTX_ID`, and `DEFAULT_CTX_ID`.

* Join of a large amount of data by using `JOIN` operations: A join operation needs to load the data to the memory for matching. This may cause an increase in the memory usage of `PLAN_CACHE_CTX_ID`, `MEMSTORE_CTX_ID`, and `DEFAULT_CTX_ID`.

* Query of a large amount of data by using the `SELECT` statement: A query operation needs to load the data to the memory for filtering and sorting. This may cause an increase in the memory usage of `PLAN_CACHE_CTX_ID`, `MEMSTORE_CTX_ID`, and `DEFAULT_CTX_ID`.

* Write of a large amount of data by using the `INSERT`, `UPDATE`, or `DELETE` statement: A write operation requires transaction management and processing. This may cause an increase in the memory usage of `TRANS_CTX_MGR_ID`, `MEMSTORE_CTX_ID`, and `DEFAULT_CTX_ID`.

* Logging of a large amount of data into the REDO log, UNDO log, or binlog: A logging operation needs to load the data to the memory. This may cause an increase in the memory usage of `TRANS_CTX_MGR_ID`, `DEFAULT_CTX_ID`, `LOB_CTX_ID`, and `TX_DATA_TABLE`.

## References

* [View memory usage information](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001103819)
* [FAQ](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001103816)
