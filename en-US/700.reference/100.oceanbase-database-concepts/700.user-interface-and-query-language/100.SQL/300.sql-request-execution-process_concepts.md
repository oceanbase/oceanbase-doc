# Execution process of SQL queries

This topic describes the typical SQL query execution process after an SQL query is received by the SQL engine.

The process is illustrated in the following figure.

![SQL](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/EN_US/700.reference/100.oceanbase-database-concepts/%E5%86%85%E6%A0%B815.png)

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>The process applies to DML and <code>SELECT</code> statements. Other statements, such as DCL statements, do not need to be processed by the optimizer. </p>
  </main>

The following table describes roles of the SQL engine modules in the SQL query execution process.

| **Module** | **Description** |
|-----------------------|--------|
| Fast-parser | Fast-parser parameterizes text strings based on lexical analysis to obtain parameterized text and constant parameters.  |
| Parser (lexical and syntactic parsing module) | After the parser receives an SQL query string sent by a user, it splits the string into "words" and parses the entire query based on the preset syntax rules. Then, it converts the SQL query string into an in-memory data structure with syntax structure information, which is called the syntax tree.  |
| Plan cache (cache module for execution plans) | The SQL engine caches the execution plan generated for every unique SQL query in the memory to speed up SQL query processing. The cached plans can be repeatedly executed in the future, which avoids repeated query optimization.  |
| Resolver (semantic parsing module) | Resolver converts the syntax tree generated by Parser into an internal data structure with database semantic information. During the conversion, Resolver translates tokens in the SQL query into the corresponding objects (such as libraries, tables, columns, and indexes) based on the database metadata to generate a statement tree.  |
| Transformer (logic rewriting module) | After Resolver generates the statement tree, Transformer analyzes the semantics of the user SQL query and rewrites it into an equivalent query based on internal rules or cost models. Then, Transformer sends the equivalent query to Optimizer for optimization. In this process, Transformer performs an equivalent transformation on the original statement tree, and the result of the transformation is still a statement tree.  |
| Optimizer | As the core of the SQL tunning process, Optimizer generates the optimal execution plans for SQL queries. During the optimization, Optimizer needs to comprehensively consider various factors, such as SQL query semantics, object data characteristics, and the physical distribution of objects. It solves many problems such as access path selection, connection order selection, connection algorithm selection, and distributed plan generation. Finally, Optimizer selects the best execution plan for each SQL query.  |
| Code generator | Code Generator converts an execution plan to executable code without any optimization.  |
| Executor | Executor starts the execution of an SQL statement.  <ul><li> For local execution plans, Executor starts by calling the operator at the top of each execution plan. The operator logic completes the entire execution process and returns the execution result.    </li><li> For remote or distributed plans, Executor divides the execution tree of each plan into multiple schedulable sub-plans and sends these sub-plans to the relevant nodes for execution by using remote procedure calls (RPCs). </li></ul> |


