| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |

# 词法

PL 的词法是其最小的独立组成部分，包括分隔符、标识符、文本、编译指令和注释。

  <main id="notice" >
    <h4>功能适用性</h4>
    <p>该内容仅适用于 OceanBase 数据库企业版。OceanBase 数据库社区版仅提供 MySQL 模式。</p>
  </main>

## 分隔符

分隔符是在 PL 中具有特殊含义的字符或字符组合。不要在分隔符中嵌入任何其他字符（包括空格字符）。

  <main id="notice" type='notice'>
    <h4>注意</h4>
    <p>本文的分隔符和 OBClient 的分隔符具有不同的含义。</p>
  </main>

PL 支持的分隔符如下表所示：


| 分隔符  |    **含义**     |
|------|---------------|
| +    | 加法运算符         |
| :=   | 赋值运算符         |
| =\>  | 关联运算符         |
| %    | 属性指示符         |
| '    | 字符串定界符        |
| .    | 元素访问符         |
| \|\| | 连接运算符         |
| /    | 除法运算符         |
| \*\* | 求幂运算符         |
| (    | 表达式或列表定界符（开始） |
| )    | 表达式或列表定界符（结束） |
| :    | 主机变量指示符       |
| ,    | 分隔符           |
| \<\< | 标签定界符（开始）     |
| \>\> | 标签定界符（结束）     |
| /\*  | 多行注释定界符（开始）   |
| \*/  | 多行注释定界符（结束）   |
| \*   | 乘法运算符         |
| "    | 带引号标识的定界符     |
| ..   | 范围运算符         |
| =    | 关系运算符（相等）     |
| \<\> | 关系运算符（不相等）    |
| !=   | 关系运算符（不相等）    |
| \~=  | 关系运算符（不相等）    |
| \^=  | 关系运算符（不相等）    |
| \<   | 关系运算符（小于）     |
| \>   | 关系运算符（大于）     |
| \<=  | 关系运算符（小于或等于）  |
| \>=  | 关系运算符（大于或等于）  |
| @    | 远程访问指示符       |
| --   | 单行注释          |
| ;    | 语句终止符         |
| -    | 减或负运算符        |



## 标识符

标识符用于命名 PL 元素，包括常量、游标、异常、关键字、标签、包、保留字、子程序、类型和变量。

标识符中的每个字符（无论是否为字母）都是有含义的。例如，标识符 `firstname` 和 `first_name` 是不同的。

您必须用一个或多个空格字符或标点符号来分隔相邻的标识符。

除非被双引号界定，PL 标识符不区分大小写。例如，标识符 `firstname`、`FirstName` 和 `FIRSTNAME` 相同。

### 保留关键字

PL 保留关键字是具有特殊含义的标识符。

不建议您将保留关键字用作普通的用户定义标识符。有关 PL 保留关键字的列表，请参见附录 [PL 保留关键字](../1500.pl-keywords-oracle.md)

### 预定义标识符

预定义标识符使用预定义包 `STANDARD` 进行声明。

有关预定义标识符的列表，请参见 [程序包 STANDARD 对 PL 环境的定义](../900.package-oracle/500.package-standard-definition-of-pl-environment-oracle.md)。

您可以使用预定义的标识符作为用户定义的标识符，但是您的本地声明会覆盖全局声明，所以不建议这样做。

### 用户自定义的标识符

用户自定义的标识符是由数据库字符集中的字符组成的、普通的或引用的标识符。

  <main id="notice" type='explain'>
    <h4>说明</h4>
    <p>应确保用户自定义的标识符可以直接表达含义。例如 <code>cost_per_employee</code> 可以从字面分析出含义，而 <code>cpe</code> 却不能。</p>
  </main>

### 普通的用户自定义标识符

用户可以自定义标识符，PL 对用户自定义标识符有如下要求和限制：

* 第一个字符必须为字母。

* 可以包含字母、数字、以及正斜线（/）、星号（\*）、and（\&）、美元符号（$）等。

* 长度不能超过 128 个字符。

* 不能使用 PL 保留字作为 PL 标识符。

* PL 标识符对大小写不敏感。

如下用户自定义标识符是有效的：

```sql
t8
telephone#
credit_limit
FirstName
OceanBase$number
money$$tree
SN##
try_again_
```

### 引号标识符

带引号的用户定义标识符用双引号括起来。

在双引号之间，允许使用数据库字符集中的任何字符，但双引号、换行符和空字符除外。

如下引号标识符是有效的：

```sql
"X+Y"
"first name"
"on/off switch"
"department(s)"
"*** body info ***"
```

带引号的用户定义标识符区分大小写，但是，如果带引号的用户定义标识符（不带双引号）是有效的普通用户定义标识符，则双引号在该标识符被引用时是可选的。如果省略，则标识符不区分大小写。

您可以将保留关键字用作带引号的用户定义标识符，但不建议这样做。由于保留关键字不是有效的普通用户定义标识符，因此必须始终将标识符括在双引号中，并且区分大小写。

```sql
obclient> DECLARE
    "HELLO" varchar2(10) := 'hello';    -- HELLO 是用户定义标识符
    "ALL" varchar2(10) := 'all';             -- ALL 是保留关键字
BEGIN
    DBMS_Output.Put_Line(Hello);       -- 可以不使用双引号，如果省略，则不区分大小写
    DBMS_Output.Put_Line("ALL");      -- 必须使用双引号
end;
/
```



输出结果为：

```sql
hello
all
```



## 文本

文本的值既不由标识符表示也不从其他值计算得出。

例如，119 是整数文本，而 'xyz' 是字符文本，但是 `1+2` 不是文本。

PL 文本包括所有 SQL 文本和 `BOOLEAN` 文本（SQL 没有）。`BOOLEAN` 文本是预定义的逻辑值 `TRUE`、`FALSE` 或 `NULL`。`NULL` 表示未知值。

在使用 PL 字符文本时，请注意：

* 字符文本区分大小写。例如，" A"和" a"不同。



* 空格字符是有含义的。例如，'abc' 和 'a b c' 不同。



* PL 没有续行符，用来表示"此字符串在下一个源代码行继续"。如果在下一个源代码行上继续一个字符串，则该字符串需要使用换行符。也可以使用串联运算符（\|\|）避免换行。






```sql
obclient> BEGIN
  DBMS_OUTPUT.PUT_LINE('The string
                       breaks here.');
  DBMS_OUTPUT.PUT_LINE('The string ' ||
                       'contains no line-break character.');
END;
/
```



输出结果为：

```sql
The string
breaks here.
The string contains no line-break character.
```



* "0"到" 9"不等于整数文本 0 到 9。由于 PL 将它们转换为整数，因此可以在算术表达式中使用。



* 具有零个字符的字符文本的值为 `NULL`，称为空字符串。但是，此 `NULL` 值不是 `BOOLEAN` 的 `NULL` 值。



* 普通字符文本由数据库字符集中的字符组成。



* 国家字符文本由国家字符集中的字符组成。






## 编译指令

编译指令是编译器在编译时处理的指令。

编译指令以保留字 `PRAGMA` 开头，后跟该编译指令的名称。编译指令可能出现在声明中或声明前。对于特定的编译指令还会有附加限制。一些编译指令包含参数，当编译器无法识别其名称或参数时，该编译指令无效。

PL 所支持的编译指令种类如下：

| 编译指令                | 意义                                                                                         |
|------------------------|--------------------------------------------------------------------------------------|
| `AUTONOMOUS_TRANSACTION` Pragma | 表示在独立的事务中执行该单独的子程序，与其他事务相互独立，不受其它会话中进行的工作的影响。 |
| `COVERAGE` Pragma               | 用于测试覆盖率，指示编译器对代码覆盖率进行分析。                                    |
| `EXCEPTION_INIT` Pragma         | 为异常分配一个代码，让异常可以通过其名称及代码来识别。                               |
| `INLINE` Pragma                 | 告诉编译器在调用处内联函数，而不是生成函数调用。                                    |
| `RESTRICT_REFERENCES` Pragma    | 限制某个单元中的 PL/SQL 子程序对表、视图等对象的引用。                              |
| `SERIALLY_REUSABLE` Pragma      | 指示包状态仅在服务器一次调用期间需要，可以减少长时间运行会话的内存开销。                |
| `UDF` Pragma                    | 表示编译器编译这个 PL/SQL 单元是一个用户定义的函数。                                |

### 示例

**示例 1：使用 `SERIALLY_REUSABLE` Pragma 的示例**

```sql
CREATE PACKAGE pkg1 IS
   PRAGMA SERIALLY_REUSABLE;
   num NUMBER := 0;
   PROCEDURE init_pkg_state(n NUMBER);
   PROCEDURE print_pkg_state;
END pkg1;
/
CREATE PACKAGE BODY pkg1 IS
   PRAGMA SERIALLY_REUSABLE;
   PROCEDURE init_pkg_state (n NUMBER) IS
   BEGIN
      pkg1.num := n;
   END;
   PROCEDURE print_pkg_state IS
   BEGIN
      dbms_output.put_line('Num: ' || pkg1.num);
   END;
END pkg1;
/
DROP PACKAGE pkg1;
```

**示例 2：使用 `AUTONOMOUS_TRANSACTION` Pragma 的示例**

```sql
CREATE OR REPLACE PROCEDURE log_error(message VARCHAR2) IS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   INSERT INTO error_log (error_message, log_date) VALUES (message, SYSDATE);
   COMMIT;
END log_error;
```

**示例 3：使用 `EXCEPTION_INIT` Pragma 的示例**


```sql
DECLARE
   deadlock_detected EXCEPTION;
   PRAGMA EXCEPTION_INIT(deadlock_detected, -60);
BEGIN
   -- 触发死锁异常的代码
   -- ...
EXCEPTION
   WHEN deadlock_detected THEN
      DBMS_OUTPUT.PUT_LINE('A deadlock was detected.');
END;
```

**示例 4：使用 `INLINE` Pragma 的示例**

```sql
CREATE OR REPLACE FUNCTION add_numbers(a NUMBER, b NUMBER) RETURN NUMBER IS
   PRAGMA INLINE(add_numbers, 'YES');
BEGIN
   RETURN a + b;
END add_numbers;
```




## 注释

注释目的是帮助其他应用程序开发人员理解您的源文本。PL 编译器会忽略注释的内容。

通常，注释用来描述每个代码段的用途。您还可以将废除的或未完成的代码段变成注释以禁用它们。

### 单行注释

单行注释以 `--` 开头，并延伸到该行的末尾。

在测试或调试程序时，可以通过注释来禁用一行代码。 例如：

```sql
-- INSERT INTO t1 VALUES(1, 1)
```


### 多行注释

多行注释以 `/ *` 开头，以 `* /` 结尾，并且可以跨越多行。

您可以使用多行注释定界符来"注释掉"代码段。请注意不要使用嵌套的多行注释。一个多行注释不能包含另一个多行注释。但是，多行注释可以包含单行注释。

如下示例会导致语法错误：

```sql
/*
  IF 1 + 2 = 3 THEN
    some_condition := TRUE;
  /* 需要  
THEN
 语句总是被执行*/
  END IF;
*/
```



## 词法间的空格字符

您可以在词法之间放置空格字符，可以使源文本更易于阅读。

如下例所示：

```sql
obclient> DECLARE
  a    NUMBER := 5;
  b    NUMBER := 1;
  max  NUMBER;
BEGIN
  IF a>b THEN max:=a;ELSE max:=b;END IF;  -- 语法正确但是不易阅读

  -- 以下语句更易于阅读:

  IF a > b THEN
    max:=a;
  ELSE
    max:=b;
  END IF;
END;
/
```
