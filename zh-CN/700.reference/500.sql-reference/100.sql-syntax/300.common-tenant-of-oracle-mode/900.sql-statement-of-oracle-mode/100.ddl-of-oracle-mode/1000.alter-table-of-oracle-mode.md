| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |

# ALTER TABLE

## 描述

该语句用来修改已存在的表的结构，包括修改表及表属性、新增列、修改列及属性、删除列等。

## 语法

```sql
alter_table_stmt:
      ALTER TABLE table_name alter_table_action_list;     

alter_table_action_list:
    alter_table_action [, alter_table_action ...]

alter_table_action:
      ADD {column_definition | (column_definition_list)}
    | ADD [CONSTRAINT [constraint_name]] UNIQUE (column_name [, column_name ]...)
    | ADD [CONSTRAINT [constraint_name]] FOREIGN KEY (column_name_list) references_clause
    | ADD [CONSTRAINT [constraint_name]] CHECK (expr)
    | ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
    | ADD CONSTRAINT constraint_name FOREIGN KEY(foreign_col_name) REFERENCES              
        reference_tbl_name(column_name);
    | ALTER INDEX index_name [VISIBLE | INVISIBLE]

    | ADD range_partition_list
    | ADD COLUMN GROUP([all columns, ]each column)
    | DROP {PARTITION | SUBPARTITION} partition_name_list [UPDATE GLOBAL INDEXES]
    | DROP TABLEGROUP
    | DROP CONSTRAINT constraint_name
    | DROP PRIMARY KEY
    | DROP COLUMN column_name
    | DROP COLUMN GROUP([all columns, ]each column)
    | {ENABLE | DISABLE} CONSTRAINT constraint_name
    | MODIFY [COLUMN] column_definition
    | MODIFY CONSTRAINT constraint_name { ENABLE | DISABLE }
    | MODIFY PRIMARY KEY (column_name_list)
    | RENAME [TO] table_name
    | RENAME COLUMN old_col_name TO new_col_name
    | RENAME { PARTITION | SUBPARITION } partition_name TO new_name
    | SET TABLEGROUP tablegroup_name
    | [SET] table_option_list
    | TRUNCATE {PARTITION | SUBPARTITION} partition_name_list [UPDATE GLOBAL INDEXES]
    | EXCHANGE PARTITION partition_name WITH TABLE non_partition_table_name INCLUDING INDEXES WITHOUT VALIDATION


rename_table_action_list:
    rename_table_action [, rename_table_action ...]

rename_table_action:
    table_name TO table_name

column_definition_list:
    column_definition [, column_definition ...]

column_definition:
    column_name data_type
    [DEFAULT const_value] [AUTO_INCREMENT]
    [NULL | NOT NULL] [[PRIMARY] KEY] [UNIQUE [KEY]] [COMMENT string_value] [SKIP_INDEX(skip_index_option_list)]

skip_index_option_list:
    skip_index_option [,skip_index_option ...]

skip_index_option:
    MIN_MAX
    | SUM

column_desc_list:
    column_desc [, column_desc ...]

column_desc:
     column_name [(length)] [ASC | DESC]

references_clause:
     REFERENCES table_name [ (column_name, column_name ...) ] [ON DELETE {SET NULL | CASCADE}]


index_option:
      [GLOBAL | LOCAL]
    | block_size
    | compression
    | STORING(column_name_list)
    | COMMENT string_value

table_option_list:
    table_option [ table_option ...]

table_option:
      table_group
    | block_size
    | compression
    | AUTO_INCREMENT [=] INT_VALUE
    | COMMENT string_value
    | parallel_clause
    | TABLE_MODE [=] 'table_mode_value'

parallel_clause:
    {NOPARALLEL | PARALLEL integer}

table_mode_value:
    NORMAL
    | QUEUING
    | MODERATE
    | SUPER
    | EXTREME

partition_option:
      PARTITION BY HASH(column_name_list)
      [subpartition_option] hash_partition_define
    | PARTITION BY RANGE (column_name_list)
      [subpartition_option] (range_partition_list)
    | PARTITION BY LIST (column_name_list)
      [subpartition_option] (list_partition_list)

/*模板化二级分区*/
subpartition_option:
      SUBPARTITION BY HASH (column_name_list) hash_subpartition_define
    | SUBPARTITION BY RANGE (column_name_list) SUBPARTITION TEMPLATE
      (range_subpartition_list)
    | SUBPARTITION BY LIST (column_name_list) SUBPARTITION TEMPLATE
      (list_subpartition_list)

/*非模板化二级分区*/
subpartition_option:
      SUBPARTITION BY HASH (column_name_list)
    | SUBPARTITION BY RANGE (column_name_list)
    | SUBPARTITION BY LIST (column_name_list)

subpartition_list:
      (hash_subpartition_list)
    | (range_subpartition_list)
    | (list_subpartition_list)

hash_partition_define:
      PARTITIONS partition_count [TABLESPACE tablespace] [compression]
    | (hash_partition_list)

hash_partition_list:
    hash_partition [, hash_partition, ...]

hash_partition:
    partition [partition_name] [subpartition_list/*仅非模板化二级分区可定义*/]

hash_subpartition_define:
      SUBPARTITIONS subpartition_count
    | SUBPARTITION TEMPLATE (hash_subpartition_list)

hash_subpartition_list:
    hash_subpartition [, hash_subpartition, ...]

hash_subpartition:
    subpartition [subpartition_name]

range_partition_list:
    range_partition [, range_partition ...]

range_partition:
    PARTITION [partition_name]
    VALUES LESS THAN {(expression_list) | (MAXVALUE)}
    [subpartition_list/*仅非模板化二级分区可定义*/]
    [ID = num] [physical_attribute_list] [compression]

range_subpartition_list:
    range_subpartition [, range_subpartition ...]

range_subpartition:
    SUBPARTITION subpartition_name
    VALUES LESS THAN {(expression_list) | MAXVALUE} [physical_attribute_list]

list_partition_list:
    list_partition [, list_partition] ...

list_partition:
    PARTITION [partition_name]
    VALUES (DEFAULT|expression_list)
    [subpartition_list/*仅非模板化二级分区可定义*/]
    [ID num] [physical_attribute_list] [compression]

list_subpartition_list:
    list_subpartition [, list_subpartition] ...

list_subpartition:
    SUBPARTITION [partition_name] VALUES (DEFAULT|expression_list) [physical_attribute_list]

expression_list:
    expression [, expression ...]

column_name_list:
    column_name [, column_name ...]

partition_name_list:
    partition_name [, partition_name ...]

partition_count | subpartition_count:
    INT_VALUE
```

## 语法说明

|                       参数                       |                描述                   |
|------------------------------------------------|----------------------------------------------------------------------------------------|
| ADD                                            | 增加列，目前不支持增加主键列。      |
| MODIFY COLUMN                             | 修改列属性。     |
| MODIFY CONSTRAINT                              | 修改约束的状态为开启或关闭，只支持外键约束和 `CHECK` 约束。    |
| DROP PRIMARY KEY                          | 删除主键。<br>**说明** 对于 Oracle 模式，如果表是外键信息的父表，则不允许删除主键。|
| DROP COLUMN                               | 删除列，不允许删除主键列或者包含索引的列。   |
| ADD UNIQUE                          | 增加唯一索引。       |
| ADD INDEX                                  | 增加普通索引      |
| ALTER INDEX                              | 修改索引属性。      |
|  FOREIGN KEY     | 增加外键。如果不指定外键名，则会使用表名 + `OBFK` + 创建时间命名。（例如，在 2021 年 8 月 1 日 00:00:00 为 `t1` 表创建的外键名称为 `t1_OBFK_1627747200000000`）。外键允许跨表交叉引用相关数据，
| ADD PARTITION                              | 增加分区。    |
| DROP {PARTITION \| SUBPARTITION}               | 删除分区： <ul><li> `PARTITION`：针对 Range、List 类型的一级分区，删除指定的分区（如果指定分区下存在二级分区，会同时删除该一级分区下的所有二级分区），包括分区定义和其中的数据，同时对分区上存在的本地索引进行维护。</li>   <li> `SUBPARTITION`：针对 \*-Range、\*-List 类型的二级分区，删除指定的二级分区，包括分区定义和其中的数据。同时对分区上存在的本地索引进行维护。</li> </ul>   如果指定 `UPDATE GLOBAL INDEXES`，则删除分区时会同步更新全局索引；如果不指定，分区表上的全局索引需要处于不可用状态。 多个分区名称之间用逗号分隔。 <br>**注意**  删除分区时，请尽量避免该分区上存在活动的事务或查询，否则可能会导致 SQL 语句报错，或者一些异常情况。 |
| TRUNCATE {PARTITION \| SUBPARTITION}           | 删除分区数据： <ul><li> `PARTITION`：针对 Range、List 类型的一级分区，清除指定分区中的全部数据（如果指定分区下存在二级分区，会同时清除该一级分区下的所有二级分区中的数据），同时对分区上存在的本地索引进行维护。</li>   <li> `SUBPARTITION`：针对 \*-Range、\*-List 类型的二级分区，清除指定二级分区中的全部数据。同时对分区上存在的本地索引进行维护。</li> </ul>   如果指定 `UPDATE GLOBAL INDEXES`，则清除分区数据时会同步更新全局索引；如果不指定，分区表上的全局索引需要处于不可用状态。 多个分区名称之间用逗号分隔。 <br>**注意**  删除分区数据时，请尽量避免该分区上存在活动的事务或查询，否则可能会导致 SQL 语句报错，或者一些异常情况。       |
| RENAME \[TO\] table_name                       | 表重命名。  |
| RENAME { PARTITION \| SUBPARITION } partition_name TO new_name| 重命名一级或者二级分区，`new_name` 指定要修改分区的新分区名称（大小写不敏感）。分区重命名操作会修改主表的相关分区，但是不会影响到局部索引的分区名，可以通过视图 `USER_TAB_PARTITIONS` 和 `USER_TAB_SUBPARTITIONS` 确认分区名修改后的结果，详细信息请参见[重命名分区](../../../../../300.database-object-management/200.manage-object-of-oracle-mode/200.manage-partitions-of-oracle-mode/310.rename-a-partition-of-oracle-mode.md)。分区重命名过程中，如果与持有相关分区锁资源的 DML 产生冲突会阻塞分区名修改操作，直到 DML 释放相关分区锁资源。|
| DROP TABLEGROUP                            | 删除表组。    |
| SET TABLEGROUP                                 | 设置表归属于哪个表组。   |
| DROP CONSTRAINT                            | 删除约束。    |
| SET BLOCK_SIZE                                 | 设置 Partition 表 `BLOCK` 大小。      |
| SET COMPRESSION                                | 设置表的压缩方式。     |
| SET USE_BLOOM_FILTER                           | 设置是否使用 BloomFilter。       |
| SET COMMENT                                    | 设置注释信息。    |
| SET PROGRESSIVE_MERGE_NUM                      | 设置渐进合并步数，取值范围是 \[0,100\]。   |
| parallel_clause                                | 指定表级别的并行度： <ul><li> `NOPARALLEL`：并行度为 `1`，为默认配置。</li>   <li> `PARALLEL integer`：指定并行度，`integer` 取值大于等于 `1`。</li></ul>  **注意**  当指定并行度时，优先级关系如下：通过 Hint 指定的并行度 \> 通过 `ALTER SESSION` 指定的并行度 \> 表级别的并行度。     |
| {ENABLE \| DISABLE} CONSTRAINT constraint_name | 修改约束的状态，支持外键约束或 `CHECK` 约束。         |
| MODIFY PRIMARY KEY                             |  修改主键。         |
| ADD COLUMN GROUP([all columns, ]each column)  | 将表变更为列存表。具体解释如下：<ul><li><code>ADD COLUMN GROUP(all columns, each column)</code>：将表变更为行存列存冗余的表。</li><li><code>ADD COLUMN GROUP(each column)</code>：将表变更为列存表。</li></ul>|
| DROP COLUMN GROUP([all columns, ]each column) | 移除表的存储格式。具体解释如下：<ul><li><code>DROP COLUMN GROUP(all columns, each column)</code>: 移除表的行存列存冗余格式。</li><li><code>DROP COLUMN GROUP(all columns)</code>: 移除表的行存格式。</li><li><code>DROP COLUMN GROUP(each column)</code>: 移除表的列存格式。</li></ul>|
| SKIP_INDEX | 修改列的 Skip Index 属性。取值如下：<ul><li><code>MIN_MAX</code>：是 Skip Index 中最通用的聚合数据类型，它会在索引节点粒度下存储被索引列的最大值、最小值和 Null Count。这种类型的数据可以加速下推的 Filter 和 `MIN/MAX` 聚合的下推。</li><li> <code>SUM</code>：用于加速数值类型的 `SUM` 聚合的下推。</li></ul>  <main id="notice" type='notice'><h4>注意</h4><p><ul><li>JSON 和空间数据类型的列禁止创建 Skip Index。</li><li>生成列禁止创建 Skip Index。</li></ul></p></main>|
| EXCHANGE PARTITION partition_name WITH TABLE non_partition_table_name INCLUDING INDEXES WITHOUT VALIDATION | 指定分区交换。其中，`partition_name` 表示分区交换中分区表的分区名称。`non_partition_table_name` 表示分区交换中非分区表名称。更多分区交换的信息，参见 [分区交换](../../../../../300.database-object-management/200.manage-object-of-oracle-mode/200.manage-partitions-of-oracle-mode/1000.exchange-partition-of-oracle-mode.md)。|
| TABLE_MODE | 可选项，用于指定合并触发阈值与合并策略，即控制数据转储后的合并行为。取值的详细介绍可参见下文 [table_mode_value](#table_mode_value)。|

### table_mode_value

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>在以下列出的 <code>TABLE_MODE</code> 模式中，除了 <code>NORMAL</code> 模式之外，所有模式都代表 <code>QUEUING</code> 表。这种 <code>QUEUING</code> 表是最基本的表类型，并且随后列出的几种模式（除了 NORMAL 模式）代表了使用更加积极的合并策略。</p>
</main>

* `NORMAL`：默认值，表示正常。在该模式下，数据转储后触发合并的概率极低。
* `QUEUING`：在该模式下，数据转储后触发合并的概率低。
* `MODERATE`：表示适度。在该模式下，数据转储后触发合并的概率为中等。
* `SUPER`：表示超级。在该模式下，数据转储后触发合并的概率高。
* `EXTREME`：表示极端。在该模式下，转储后触发合并的概率较高。

更多有关合并的信息，请参见 [自适应合并](../../../../../200.system-management/500.manage-data-storage/200.merge-management/320.adaptive-compaction.md)。

## 示例

* 修改表 `tbl1` 中字段 `col1` 的字段类型。

  ```shell
  obclient> CREATE TABLE tbl1(col1 VARCHAR(3));
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl1 MODIFY col1 CHAR(10);
  Query OK, 0 rows affected

  obclient> DESCRIBE tbl1;
  +-------+----------+------+-----+---------+-------+
  | FIELD | TYPE     | NULL | KEY | DEFAULT | EXTRA |
  +-------+----------+------+-----+---------+-------+
  | COL1  | CHAR(10) | YES  | NULL | NULL    | NULL  |
  +-------+----------+------+-----+---------+-------+
  1 row in set
  ```

* 修改表 `tbl1` 中列 `col1` 的名称为 `col2`。

  ```shell
  obclient> ALTER TABLE tbl1 RENAME COLUMN col1 TO col2;
  Query OK, 0 rows affected

  obclient> DESCRIBE tbl1;
  +-------+-------------+------+-----+---------+-------+
  | FIELD | TYPE        | NULL | KEY | DEFAULT | EXTRA |
  +-------+-------------+------+-----+---------+-------+
  | COL2  | VARCHAR2(10) | YES  | NULL | NULL    | NULL  |
  +-------+-------------+------+-----+---------+-------+
  1 row in set
  ```

* 增加和删除列。

  * 创建表 `tbl2`。

    ```shell
    obclient> CREATE TABLE tbl2 (col1 NUMBER(30) PRIMARY KEY,col2 VARCHAR(50));
    Query OK, 0 rows affected
    ```

  * 对表 `tbl2` 增加 `col3` 列。

    ```shell
    obclient> ALTER TABLE tbl2 ADD col3 NUMBER(30);
    Query OK, 0 rows affected

    obclient> DESCRIBE tbl2;
    +-------+--------------+------+-----+---------+-------+
    | FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
    +-------+--------------+------+-----+---------+-------+
    | COL1  | NUMBER(30)   | NO   | PRI | NULL    | NULL  |
    | COL2  | VARCHAR2(50) | YES  | NULL | NULL    | NULL  |
    | COL3  | NUMBER(30)   | YES  | NULL | NULL    | NULL  |
    +-------+--------------+------+-----+---------+-------+
    3 rows in set
    ```

  * 删除表 `tbl2` 的 `col3` 列。

    ```shell
    obclient> ALTER TABLE tbl2 DROP COLUMN col3;
    Query OK, 0 rows affected

    obclient> DESCRIBE tbl2;
    +-------+--------------+------+-----+---------+-------+
    | FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
    +-------+--------------+------+-----+---------+-------+
    | COL1  | NUMBER(30)   | NO   | PRI | NULL    | NULL  |
    | COL2  | VARCHAR2(50) | YES  | NULL | NULL    | NULL  |
    +-------+--------------+------+-----+---------+-------+
    2 rows in set
    ```

  * 为表 `tbl2` 创建唯一性索引。

    ```shell
    obclient> CREATE TABLE tbl2 (col1 NUMBER(30) PRIMARY KEY,col2 VARCHAR(50), col3 INT);
    Query OK, 0 rows affected

    obclient> ALTER TABLE tbl2 ADD CONSTRAINT constraint_TBL2 UNIQUE (col2, col3);
    Query OK, 0 rows affected

    obclient [SYS]> DESC tbl2;
    +-------+--------------+------+-----+---------+-------+
    | FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
    +-------+--------------+------+-----+---------+-------+
    | COL1  | NUMBER(30)   | NO   | PRI | NULL    | NULL  |
    | COL2  | VARCHAR2(50) | YES  | MUL | NULL    | NULL  |
    | COL3  | NUMBER(38)   | YES  | NULL | NULL    | NULL  |
    +-------+--------------+------+-----+---------+-------+
    3 rows in set

    obclient> INSERT INTO tbl2 VALUES('1','2','2');
    Query OK, 1 row affected

    obclient> INSERT INTO tbl2 VALUES('2','2','2');
    ORA-00001: unique constraint '2-2' for key 'CONSTRAINT_TBL2' violated

    obclient> INSERT INTO tbl2 VALUES('2','3','2');
    Query OK, 1 row affected
    ```

* 为表 `ref_t2` 添加外键，当 `DELETE` 操作影响与子表相匹配行的父表中键值时，执行 `SET NULL` 操作。

  ```shell
  obclient> CREATE TABLE ref_t1(c1 INT PRIMARY KEY,C2 INT);
  Query OK, 0 rows affected

  obclient> CREATE TABLE ref_t2(c1 INT PRIMARY KEY,C2 INT);
  Query OK, 0 rows affected

  obclient> ALTER TABLE ref_t2 ADD CONSTRAINT fk1 FOREIGN KEY (c2) REFERENCES ref_t1(c1) ON DELETE SET NULL;
  Query OK, 0 row affected
  ```

* 为非模板化二级分区表 `tbl3` 的一级分区 `p1` 下添加二级分区 `p1_r4`。

  ```shell
  obclient> ALTER TABLE tbl3 MODIFY PARTITION p1 ADD SUBPARTITION p1_r4 VALUES LESS THAN(2022);
  Query OK, 0 rows affected
  ```

* 删除非模板化二级分区表 `tbl3` 的二级分区 `p3_r3`。

  ```shell
  obclient> ALTER TABLE tbl3 DROP SUBPARTITION p2_r3;
  Query OK, 0 rows affected
  ```

* 为非模板化二级分区表 `tbl3` 添加一级分区 `p4`，需要同时指定一级分区的定义和该分区下的二级分区定义。

  ```shell
  obclient> ALTER TABLE tbl3 ADD PARTITION p4 VALUES LESS THAN (400)
  (
    SUBPARTITION p4_r1 VALUES LESS THAN (2019),
    SUBPARTITION p4_r2 VALUES LESS THAN (2020),
    SUBPARTITION p4_r3 VALUES LESS THAN (2021)
  );
  Query OK, 0 rows affected
  ```

* 为模板化二级分区表 `tbl4` 添加一级分区 `p3`，只需要指定一级分区的定义，二级分区的定义会自动按照模板填充。

  ```shell
  obclient> CREATE TABLE tbl4(col1 INT, col2 INT, PRIMARY KEY(col1,col2))
       PARTITION BY RANGE(col1)
       SUBPARTITION BY RANGE(col2)
       SUBPARTITION TEMPLATE
       (
       SUBPARTITION p0 VALUES LESS THAN (50),
       SUBPARTITION p1 VALUES LESS THAN (100)
       )
       (
       PARTITION p0 VALUES LESS THAN (100),
       PARTITION p1 VALUES LESS THAN (200),
       PARTITION p2 VALUES LESS THAN (300)
       );
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl4 ADD PARTITION p3 VALUES LESS THAN (400);
  Query OK, 0 rows affected
  ```

* 修改表 `tbl5` 的并行度为 `3`。

  ```shell
  obclient> CREATE TABLE tbl5(col1 int primary key, col2 int) PARALLEL 5;
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl5 PARALLEL 3;
  Query OK, 0 rows affected
  ```

  或者：

  ```shell
  obclient> CREATE TABLE tbl5(col1 int primary key, col2 int) PARALLEL 5;
  Query OK, 0 rows affected
  obclient> ALTER /*+ parallel(3) */ TABLE tbl5;

* 修改外键约束的状态。

  ```shell
  obclient> CREATE TABLE MMS_GROUPUSER (
    "ID" VARCHAR2(254 BYTE) NOT NULL,
    "GROUPID" VARCHAR2(254 BYTE),
    "USERID" VARCHAR2(254 BYTE),
    CONSTRAINT "PK_MMS_GROUPUSER" PRIMARY KEY ("ID"),
    CONSTRAINT "FK_MMS_GROUPUSER_02" FOREIGN KEY ("GROUPID") REFERENCES MMS_GROUPUSER ("ID") ON DELETE CASCADE DISABLE
  );
  Query OK, 0 rows affected

  obclient> SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,STATUS FROM user_constraints WHERE CONSTRAINT_NAME LIKE 'FK_MMS_GROUPUSE%';
  +---------------------+-----------------+---------------+----------+
  | CONSTRAINT_NAME     | CONSTRAINT_TYPE | TABLE_NAME    | STATUS   |
  +---------------------+-----------------+---------------+----------+
  | FK_MMS_GROUPUSER_02 | R               | MMS_GROUPUSER | DISABLED |
  +---------------------+-----------------+---------------+----------+
  1 row in set

  obclient> ALTER TABLE MMS_GROUPUSER ENABLE CONSTRAINT FK_MMS_GROUPUSER_02;
  Query OK, 0 rows affected

  obclient> SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,STATUS FROM user_constraints WHERE CONSTRAINT_NAME LIKE 'FK_MMS_GROUPUSE%';
  +---------------------+-----------------+---------------+---------+
  | CONSTRAINT_NAME     | CONSTRAINT_TYPE | TABLE_NAME    | STATUS  |
  +---------------------+-----------------+---------------+---------+
  | FK_MMS_GROUPUSER_02 | R               | MMS_GROUPUSER | ENABLED |
  +---------------------+-----------------+---------------+---------+
  1 row in set
  ```

* 清空分区表 `tbl6` 的分区 `M202001` 和 `M202002` 中的全部数据。

  ```shell
  obclient> CREATE TABLE tbl6 (log_id number NOT NULL,log_value varchar2(50),log_date date NOT NULL DEFAULT sysdate)
  PARTITION BY RANGE(log_date)
  (
      PARTITION M202001 VALUES LESS THAN(TO_DATE('2020/02/01','YYYY/MM/DD'))
      , PARTITION M202002 VALUES LESS THAN(TO_DATE('2020/03/01','YYYY/MM/DD'))
      , PARTITION M202003 VALUES LESS THAN(TO_DATE('2020/04/01','YYYY/MM/DD'))
      , PARTITION M202004 VALUES LESS THAN(TO_DATE('2020/05/01','YYYY/MM/DD'))
      , PARTITION M202005 VALUES LESS THAN(TO_DATE('2020/06/01','YYYY/MM/DD'))
      , PARTITION MMAX VALUES LESS THAN (MAXVALUE)
  );
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl6 TRUNCATE PARTITION M202001, M202002 UPDATE GLOBAL INDEXES;
  Query OK, 0 rows affected
  ```

* 删除表 `tbl7` 的 `CHECK` 约束 `tbl7_equal_check1`。

  ```shell
  obclient> CREATE TABLE tbl7 (col1 INT, col2 INT, col3 INT,CONSTRAINT tbl7_equal_check1 CHECK(col2 = col3 * 2) ENABLE VALIDATE);
  Query OK, 0 rows affected

  obclient> SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,STATUS FROM user_constraints WHERE TABLE_NAME LIKE 'TBL%';
  +-------------------+-----------------+------------+---------+
  | CONSTRAINT_NAME   | CONSTRAINT_TYPE | TABLE_NAME | STATUS  |
  +-------------------+-----------------+------------+---------+
  | TBL8_EQUAL_CHECK1 | C               | TBL8       | ENABLED |
  | TBL7_EQUAL_CHECK1 | C               | TBL7       | ENABLED |
  +-------------------+-----------------+------------+---------+
  2 rows in set

  obclient> ALTER TABLE tbl7 DROP CONSTRAINT tbl7_equal_check1;
  Query OK, 0 rows affected

  obclient> SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,STATUS FROM user_constraints WHERE TABLE_NAME LIKE 'TBL%';
  +-------------------+-----------------+------------+---------+
  | CONSTRAINT_NAME   | CONSTRAINT_TYPE | TABLE_NAME | STATUS  |
  +-------------------+-----------------+------------+---------+
  | TBL8_EQUAL_CHECK1 | C               | TBL8       | ENABLED |
  +-------------------+-----------------+------------+---------+
  1 row in set
  ```

* 把表 `tbl8` 从表组 `tblgroup1` 中移到表组 `tblgroup2` 中。

  ```shell
  obclient> SHOW TABLEGROUPS;
  +-----------------+------------+---------------+
  | TABLEGROUP_NAME | TABLE_NAME | DATABASE_NAME |
  +-----------------+------------+---------------+
  | TBLGROUP1             | TBL8         | SYS           |
  | TBLGROUP2             | NULL       | NULL          |
  | oceanbase       | NULL       | NULL          |
  +-----------------+------------+---------------+
  3 rows in set

  obclient> ALTER TABLE tbl8 SET TABLEGROUP tblgroup2;
  Query OK, 0 rows affected

  obclient> SHOW TABLEGROUPS;
  +-----------------+------------+---------------+
  | TABLEGROUP_NAME | TABLE_NAME | DATABASE_NAME |
  +-----------------+------------+---------------+
  | TBLGROUP1             | NULL       | NULL          |
  | TBLGROUP2             | TBL8         | SYS           |
  | oceanbase       | NULL       | NULL          |
  +-----------------+------------+---------------+
  3 rows in set
  ```

* 为表 `primary_table` 添加外键约束 `cons_fk1`。

  ```shell
  obclient> CREATE TABLE primary_table (id NUMBER PRIMARY KEY, names VARCHAR(100) NOT NULL, foreign_col NUMBER);
  Query OK, 0 rows affected
  obclient> CREATE TABLE reference_table (id NUMBER PRIMARY key, comments VARCHAR2(100) NOT NULL);
  Query OK, 0 rows affected
  obclient> ALTER TABLE primary_table ADD CONSTRAINT cons_fk1 FOREIGN KEY(foreign_col) REFERENCES reference_table(id);
  Query OK, 0 rows affected
  ```

* 为表 `tbl9` 添加主键约束 `tbl1_pk`。

  ```shell
  obclient> CREATE TABLE tbl9 (col1 NUMBER, col2 INT,col3 VARCHAR2(100));
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl9 ADD CONSTRAINT tbl1_pk PRIMARY KEY (col1);
  Query OK, 0 rows affected
  ```

* 修改表 `tbl9` 的主键为 `col2` 列。

  ```shell
  obclient> ALTER TABLE tbl9 MODIFY PRIMARY KEY(col2);
  Query OK, 0 rows affected
  ```

* 删除表 `tbl9` 的主键。

  ```shell
  obclient> ALTER TABLE tbl9 DROP PRIMARY KEY;
  Query OK, 0 rows affected
  ```

* 重命名一级分区和二级分区。

  ```shell
  /* 创建二级分区表 range_range_table 并基于 col1 创建本地索引 */
  CREATE TABLE range_range_table(col1 INT, col2 INT, col3 INT)
      PARTITION BY RANGE(col1)
      SUBPARTITION BY RANGE(col2)
         (PARTITION p0 VALUES LESS THAN(100)
             (SUBPARTITION sp0 VALUES LESS THAN(100),
              SUBPARTITION sp1 VALUES LESS THAN(200)
             ),
          PARTITION p1 VALUES LESS THAN(200)
             (SUBPARTITION sp2 VALUES LESS THAN(100),
              SUBPARTITION sp3 VALUES LESS THAN(200),
              SUBPARTITION sp4 VALUES LESS THAN(300)
             )
          );

  CREATE INDEX local_idx_for_range_range_tb ON range_range_table (col1) LOCAL;

  /* 重命名一级分区，但修改不会影响到局部索引的分区名 */

  obclient> SELECT partition_name FROM SYS.USER_TAB_PARTITIONS WHERE table_name = 'RANGE_RANGE_TABLE';
  +----------------+
  | PARTITION_NAME |
  +----------------+
  | P0             |
  | P1             |
  +----------------+
  2 rows in set

  obclient> ALTER TABLE range_range_table RENAME PARTITION p0 TO p10;
  Query OK, 0 rows affected

  obclient> SELECT partition_name FROM SYS.USER_TAB_PARTITIONS WHERE table_name = 'RANGE_RANGE_TABLE';
  +----------------+
  | PARTITION_NAME |
  +----------------+
  | P10            |
  | P1             |
  +----------------+
  2 rows in set

  obclient> SELECT partition_name FROM SYS.USER_IND_PARTITIONS WHERE index_name = 'LOCAL_IDX_FOR_RANGE_RANGE_TB';
  +----------------+
  | PARTITION_NAME |
  +----------------+
  | P0             |
  | P1             |
  +----------------+
  2 rows in set

  /* 重命名二级分区，但修改不会影响到局部索引的分区名 */
  obclient> SELECT partition_name, subpartition_name FROM SYS.USER_TAB_SUBPARTITIONS WHERE table_name = 'RANGE_RANGE_TABLE';
  +----------------+-------------------+
  | PARTITION_NAME | SUBPARTITION_NAME |
  +----------------+-------------------+
  | P10            | SP0               |
  | P10            | SP1               |
  | P1             | SP2               |
  | P1             | SP3               |
  | P1             | SP4               |
  +----------------+-------------------+
  5 rows in set

  obclient> ALTER TABLE range_range_table RENAME SUBPARTITION sp0 TO sp10;
  Query OK, 0 rows affected

  obclient> SELECT partition_name, subpartition_name FROM SYS.USER_TAB_SUBPARTITIONS WHERE table_name = 'RANGE_RANGE_TABLE';
  +----------------+-------------------+
  | PARTITION_NAME | SUBPARTITION_NAME |
  +----------------+-------------------+
  | P10            | SP10              |
  | P10            | SP1               |
  | P1             | SP2               |
  | P1             | SP3               |
  | P1             | SP4               |
  +----------------+-------------------+
  5 rows in set

  obclient> SELECT partition_name, subpartition_name FROM SYS.USER_IND_SUBPARTITIONS WHERE index_name = 'LOCAL_IDX_FOR_RANGE_RANGE_TB';
  +----------------+-------------------+
  | PARTITION_NAME | SUBPARTITION_NAME |
  +----------------+-------------------+
  | P0             | SP0               |
  | P0             | SP1               |
  | P1             | SP2               |
  | P1             | SP3               |
  | P1             | SP4               |
  +----------------+-------------------+
  5 rows in set
  ```

* 修改表的列存属性。

  1. 使用下面 SQL 语句创建表 `tbl1`。

      ```shell
      CREATE TABLE tbl1 (col1 INT PRIMARY KEY, col2 VARCHAR(50));
      ```

  2. 将表 `tbl1` 的变更为行存列存冗余表，然后再删除行存列存冗余属性。

      ```shell
      ALTER TABLE tbl1 ADD COLUMN GROUP(all columns, each column);
      ```

      ```shell
      ALTER TABLE tbl1 DROP COLUMN GROUP(all columns, each column);
      ```

  3. 将表 `tbl1` 的变更为列存表，然后再删除列存属性。

      ```shell
      ALTER TABLE tbl1 ADD COLUMN GROUP(each column);
      ```

      ```shell
      ALTER TABLE tbl1 DROP COLUMN GROUP(each column);
      ```

* 修改表中列的 Skip Index 属性。

  1. 使用下面 SQL 语句创建表 `test_skidx`。

      ```shell
      CREATE TABLE test_skidx(
          col1 NUMBER SKIP_INDEX(MIN_MAX, SUM),
          col2 FLOAT SKIP_INDEX(MIN_MAX),
          col3 VARCHAR2(1024) SKIP_INDEX(MIN_MAX),
          col4 CHAR(10)
        );
      ```

  2. 修改表 `test_skidx` 中列 `col2` 的 Skip Index 属性为 `SUM` Skip Index 类型。

      ```shell
      ALTER TABLE test_skidx MODIFY col2 FLOAT SKIP_INDEX(SUM);
      ```

  3. 建表后新增列的 Skip Index 属性。为表 `test_skidx` 中列 `col4` 增加的 `MIN_MAX` Skip Index 类型。

      ```shell
      ALTER TABLE test_skidx MODIFY col4 CHAR(10) SKIP_INDEX(MIN_MAX);
      ```

  4. 建表后删除列的 Skip Index 属性。删除表 `test_skidx` 中列 `col1` 的 Skip Index 属性。

      ```shell
      ALTER TABLE test_skidx MODIFY col1 NUMBER SKIP_INDEX();
      ```

## 相关文档

[更改表](../../../../../300.database-object-management/200.manage-object-of-oracle-mode/100.manage-tables-of-oracle-mode/600.change-table-of-oracle-mode.md)
