|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# 列存

OceanBase 数据库从诞生起就一直坚持 LSM-Tree 架构，不断打磨功能支持了各类典型的 TP 类型业务，持续优化性能满足各种极限负载压力，积累了大量工程实践经验，打造出一套纯自主研发且具备充分特色的业界领先 LSM-tree 存储引擎。在 V4.3.0 版本，基于原有技术积累，OceanBase 数据库存储引擎继续扩展，实现对列存的支持，实现存储一体化，一套代码一个架构一个 OBServer，列存数据和行存数据完美共存，真正实现了对 TP 类和 AP 类查询的性能的兼顾。

## 整体架构

OceanBase 数据库作为原生分布式数据库，用户数据默认为多副本存储。为了利用多副本的优势，进一步增强用户在数据强校验以及迁移数据重用等方面的体验，自研的 LSM-Tree 存储引擎也做了较多的针对性设计。首先，每个用户数据整体可以分成以下两大部分：

* 基线数据

  不同于其它主流 LSM-Tree 存储引擎的数据库，OceanBase 数据库利用分布式多副本的基础，提出了 “每日合并” 的概念，租户会定期或者根据用户操作选择一个全局版本号，租户数据的所有副本均以该版本完成一轮 Major Compaction，最后生成该版本的基线数据。所有副本同一个版本的基线数据物理上完全一致。

* 增量数据

  相对基线数据而言，用户数据在最新版本的基线数据之后所有写入的数据均属于增量数据。具体来说，增量数据可以是用户刚写入 MemTable 的内存数据，也可以是已经转储为 SSTable 的磁盘数据。 对于用户数据的所有副本来说，增量数据中的各个副本独立维护，不保证一致，并且不同于基线数据是基于指定版本生成，增量数据会包含所有多版本数据。

基于列存应用场景随机更新量可控的背景，OceanBase 数据库结合自身基线数据和增量数据的特点，提出了一套对上层透明的列存实现方式：

* 基线数据存储为列存模式，增量数据保持行存，用户的所有 DML 操作不受影响，上下游同步无缝接入，列存表数据仍然可以像行存表一样进行所有事务操作。

* 列存模式下，每列数据存储为一个独立的 SSTable，所有列的 SSTable 组合成为一个虚拟 SSTable 作为用户的列存基线数据，如下图所示。

* 根据用户建表时指定的表的存储模式，基线数据可以有行存、列存、行存列存冗余三种模式。

![列存模式](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.3.0/structure.png)

除了在存储引擎中实现了列存模式，为了让用户能够更便捷地从其它 AP 数据库中迁移过来，以及帮助之前有 AP 需求的老用户升级到列存，OceanBase 数据库从优化器到执行器以及存储等其它相关模块，都针对列存进行了适配和优化，让用户迁移到列存后对业务基本无感，能够像使用行存一样享受到列存带来的性能优势。也让 OceanBase 数据库真正实现了 TP/AP 一体化，实现一套引擎一套代码支持不同类型业务的目标，打造完善的 HTAP 引擎。

![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.3.0/2.png)

* SQL 一体化

  * 为列存设计实现了新的代价模型，并增加列存相关统计信息，优化器根据数据表的存储模式和代价自动选择计划。

  * 实现新的向量化引擎，完成关键算子的新引擎重构，不同类型计划根据代价自适应选择向量化以及批大小。

* 存储一体化

  * 对于用户数据，可以根据业务负载类型将表的存储模式灵活设置为列存、行存或者行列冗余模式，用户在执行查询或备份恢复等操作时完全透明。

  * 列存表完全支持所有在线及离线 DDL 操作，完全支持所有数据类型及二级索引的创建，以保证用户在使用上与行存一样。

* 事务一体化

  增量数据全部为行存，事务内修改日志内容以及进行多版本控制等与行存逻辑完全一致。

## 核心特性

* 自适应 Compaction

  引入新的列存存储模式之后，数据合并行为与原有行存数据有较大变化。具体表现在，由于增量数据全部是行存，它需要与基线数据合并后再拆分到每个列的独立 SSTable 中，合并时间和资源占用相对行存会有较大增长。

  为了加速列存表的合并速度，OceanBase 数据库 对 Compaction 流程进行了大幅优化。对于列存表，除了能够像行存表一样进行水平拆分并行合并加速之外，还增加了垂直拆分加速，列存表会将多个列的合并动作放在一个合并任务内进行，并且一个任务内的列数能够根据系统资源自主选择升降，保证整体在合并速度以及内存开销达到更好的平衡。

* 列式编码算法

  一直以来，OceanBase 数据库的存储数据都会经过两级压缩，第一级是 OceanBase 数据库自研的行列混合编码压缩；第二级是通用压缩。其中，行列混合编码由于是数据库内置算法，可以支持不解压直接查询，同时还可以利用编码信息进行查询过滤加速，尤其对 AP 类查询会有极大的加速。 

  由于原有行列混合编码算法仍然偏向行组织，OceanBase 数据库针对列存表又实现了全新的列式编码算法。相比原有的编码算法，新算法支持查询的全面向量化执行，支持兼容不同指令集的 SIMD 优化，同时针对数值类型大幅提高压缩比，实现了对原有算法在性能和压缩比上的全面提升。

* Skip Index

  常见的列存数据库一般均会对每列数据按照一定的粒度进行预聚合计算，聚合的结果随数据一起持久化，以便当用户查询请求访问列数据时，数据库能够通过预聚合数据过滤数据，大幅减少数据访问开销，减少不必要的 IO 消耗。 

  在列存引擎中，OceanBase 数据库同样增加了 Skip Index 的支持，针对每列数据会按照微块粒度进行最大值、最小值以及 Null 总量等多个维度的聚合计算，并逐层向上聚合累加获得宏块、SSTable 等更大粒度的聚合值，用户在查询时，系统能够根据扫描范围不断下钻选取合适粒度的聚合值进行过滤以及聚合输出。

* 查询下压

  OceanBase 数据库从 V3.2.x 版本开始初步支持简单的查询下压，从 V4.x 版本开始，存储全面支持了向量化以及更多的下压支持，在列存引擎中，下压功能进一步得到增强和扩展，具体表现在以下几个方面：

  * 所有查询 Filter 下压，同时根据 Filter 类型，能够进一步利用 Skip Index 以及编码信息加速。

  * 常用聚合函数的下压，非 Group By 场景下，目前 `COUNT()`/`MAX()`/`MIN()`/`SUM()`/`AVG()` 等聚合函数已能下压到存储引擎。

  * Group By 下压，在 NDV（Number of Distinct Values） 较少的列上，支持 Group By 下压存储计算，利用微块内字典信息进行大幅加速。

## 列存的使用

### 创建列存表

列存引入新的语法 `WITH COLUMN GROUP`，当用户建表时最后指定 `WITH COLUMN GROUP(each column)` 即代表创建列存表。

```sql
obclient> CREATE TABLE tt_column_store (c1 int PRIMARY KEY, c2 int , c3 int) WITH COLUMN GROUP (each column);
```

创建后，查看建表语句。

```sql
obclient> SHOW CREATE TABLE tt_column_store;
```

结果如下：

```shell
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table           | Create Table                                                                                                                                                                                                                                                                                                                                        |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| tt_column_store | CREATE TABLE `tt_column_store` (
  `c1` int(11) NOT NULL,
  `c2` int(11) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 WITH COLUMN GROUP(each column) |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set
```

### 创建列存行存冗余表

对于部分场景，用户可以忍受一定程度的数据冗余，希望带来 AP/TP 业务场景的兼顾，此时可以增加行存数据的冗余，通过 `WITH COLUMN GROUP` 语法增加指定 `all columns` 即可。

```sql
obclient> CREATE TABLE  tt_column_row (c1 int PRIMARY KEY, c2 int , c3 int) WITH COLUMN GROUP (all columns, each column);
```

创建后，查看建表语句。

```sql
obclient> SHOW CREATE TABLE  tt_column_row;
```

结果如下：

```shell
+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table         | Create Table                                                                                                                                                                                                                                                                                                                                                   |
+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| tt_column_row | CREATE TABLE `tt_column_row` (
  `c1` int(11) NOT NULL,
  `c2` int(11) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 WITH COLUMN GROUP(all columns, each column) |
+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set
```

### 列存扫描

* 查看执行计划中是否有列存扫描计划

  以上面创建的 `tt_column_store` 列存表为例。

  ```sql
  obclient> EXPLAIN SELECT * FROM tt_column_store;
  ```

  结果如下。

  ```shell
  +--------------------------------------------------------------------------------------------------------+
  | Query Plan                                                                                             |
  +--------------------------------------------------------------------------------------------------------+
  | =================================================================                                      |
  | |ID|OPERATOR              |NAME           |EST.ROWS|EST.TIME(us)|                                      |
  | -----------------------------------------------------------------                                      |
  | |0 |COLUMN TABLE FULL SCAN|tt_column_store|1       |7           |                                      |
  | =================================================================                                      |
  | Outputs & filters:                                                                                     |
  | -------------------------------------                                                                  |
  |   0 - output([tt_column_store.c1], [tt_column_store.c2], [tt_column_store.c3]), filter(nil), rowset=16 |
  |       access([tt_column_store.c1], [tt_column_store.c2], [tt_column_store.c3]), partitions(p0)         |
  |       is_index_back=false, is_global_index=false,                                                      |
  |       range_key([tt_column_store.c1]), range(MIN ; MAX)always true                                     |
  +--------------------------------------------------------------------------------------------------------+
  11 rows in set
  ```

  根据查询结果可知，计划展示上显示 `COLUMN TABLE FULL SCAN`，用于描述列存表的范围扫描。

  计划展示上显示 `COLUMN TABLE GET`，用于描述列存表上的指定主键的 Get 操作，示例如下。
  
  ```sql
  obclient> EXPLAIN SELECT * FROM tt_column_store WHERE c1 = 1;
  ```

  结果如下。

  ```shell
  +--------------------------------------------------------------------------------------------------------+
  | Query Plan                                                                                             |
  +--------------------------------------------------------------------------------------------------------+
  | ===========================================================                                            |
  | |ID|OPERATOR        |NAME           |EST.ROWS|EST.TIME(us)|                                            |
  | -----------------------------------------------------------                                            |
  | |0 |COLUMN TABLE GET|tt_column_store|1       |14          |                                            |
  | ===========================================================                                            |
  | Outputs & filters:                                                                                     |
  | -------------------------------------                                                                  |
  |   0 - output([tt_column_store.c1], [tt_column_store.c2], [tt_column_store.c3]), filter(nil), rowset=16 |
  |       access([tt_column_store.c1], [tt_column_store.c2], [tt_column_store.c3]), partitions(p0)         |
  |       is_index_back=false, is_global_index=false,                                                      |
  |       range_key([tt_column_store.c1]), range[1 ; 1],                                                   |
  |       range_cond([tt_column_store.c1 = 1])                                                             |
  +--------------------------------------------------------------------------------------------------------+
  12 rows in set
  ```

* 通过 Hint 指定列存行存冗余表是否走列存扫描

  对于列存行存冗余表，优化器会根据代价选择走行存或者列存扫描，例如，简单场景做全表扫描，系统会默认使用行存生成计划。

  以上面创建的列存行存冗余表 `tt_column_row` 为例。

  ```sql
  obclient> EXPLAIN SELECT * FROM tt_column_row;
  ```

  结果如下。

  ```shell
  +--------------------------------------------------------------------------------------------------+
  | Query Plan                                                                                       |
  +--------------------------------------------------------------------------------------------------+
  | ========================================================                                         |
  | |ID|OPERATOR       |NAME         |EST.ROWS|EST.TIME(us)|                                         |
  | --------------------------------------------------------                                         |
  | |0 |TABLE FULL SCAN|tt_column_row|1       |3           |                                         |
  | ========================================================                                         |
  | Outputs & filters:                                                                               |
  | -------------------------------------                                                            |
  |   0 - output([tt_column_row.c1], [tt_column_row.c2], [tt_column_row.c3]), filter(nil), rowset=16 |
  |       access([tt_column_row.c1], [tt_column_row.c2], [tt_column_row.c3]), partitions(p0)         |
  |       is_index_back=false, is_global_index=false,                                                |
  |       range_key([tt_column_row.c1]), range(MIN ; MAX)always true                                 |
  +--------------------------------------------------------------------------------------------------+
  11 rows in set
  ```

  此时，如果用户还是希望手动调优，走列存扫描，可以通过 `hint USE_COLUMN_TABLE` 语句来强制 `tt_column_row` 表走列存扫描，语句如下。

  ```sql
  obclient> EXPLAIN SELECT/*+ USE_COLUMN_TABLE(tt_column_row) */ * FROM tt_column_row;
  ```

  结果如下。

  ```shell
  +--------------------------------------------------------------------------------------------------+
  | Query Plan                                                                                       |
  +--------------------------------------------------------------------------------------------------+
  | ===============================================================                                  |
  | |ID|OPERATOR              |NAME         |EST.ROWS|EST.TIME(us)|                                  |
  | ---------------------------------------------------------------                                  |
  | |0 |COLUMN TABLE FULL SCAN|tt_column_row|1       |7           |                                  |
  | ===============================================================                                  |
  | Outputs & filters:                                                                               |
  | -------------------------------------                                                            |
  |   0 - output([tt_column_row.c1], [tt_column_row.c2], [tt_column_row.c3]), filter(nil), rowset=16 |
  |       access([tt_column_row.c1], [tt_column_row.c2], [tt_column_row.c3]), partitions(p0)         |
  |       is_index_back=false, is_global_index=false,                                                |
  |       range_key([tt_column_row.c1]), range(MIN ; MAX)always true                                 |
  +--------------------------------------------------------------------------------------------------+
  11 rows in set
  ```

  类似的，通过使用 `hint NO_USE_COLUMN_TABLE` 语句可以强制表不走列存扫描。

  ```sql
  obclient> EXPLAIN SELECT /*+ NO_USE_COLUMN_TABLE(tt_column_row) */ c2 FROM tt_column_row;
  ```

  结果如下。

  ```shell
  +------------------------------------------------------------------+
  | Query Plan                                                       |
  +------------------------------------------------------------------+
  | ========================================================         |
  | |ID|OPERATOR       |NAME         |EST.ROWS|EST.TIME(us)|         |
  | --------------------------------------------------------         |
  | |0 |TABLE FULL SCAN|tt_column_row|1       |3           |         |
  | ========================================================         |
  | Outputs & filters:                                               |
  | -------------------------------------                            |
  |   0 - output([tt_column_row.c2]), filter(nil), rowset=16         |
  |       access([tt_column_row.c2]), partitions(p0)                 |
  |       is_index_back=false, is_global_index=false,                |
  |       range_key([tt_column_row.c1]), range(MIN ; MAX)always true |
  +------------------------------------------------------------------+
  11 rows in set
  ```







