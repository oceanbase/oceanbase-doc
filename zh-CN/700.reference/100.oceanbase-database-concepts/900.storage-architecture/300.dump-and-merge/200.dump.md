# 转储

OceanBase 数据库的存储引擎基于 LSM-Tree 架构，数据大体上被分为 MemTable 和 SSTable 两部分，当 MemTable 的大小超过一定阈值时，就需要将 MemTable 中的数据转存到 SSTable 中以释放内存，我们将这一过程称之为转储。

## 分层转储

在 OceanBase 数据库 V2.1 版本之前，在同一时刻只会维护一个转储 SSTable，当 MemTable 需要进行转储时，会将 MemTable 中的数据和转储 SSTable 中的数据进行归并，这会带来一个问题，随着转储次数不断增多，转储 SSTable 的大小也越来越大，而一次转储需要操作的数据量也越来越多，导致转储速度越来越慢，进而导致 MemTable 内存爆。从 V2.2 版本开始，OceanBase 数据库引入了分层转储策略。

![转储](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/700.reference/100.oceanbase-database-concepts/900.storage-architecture/300.dump-and-merge/dump.png)

参考业界的部分实现，结合目前 OceanBase 数据库架构，OceanBase 数据库的分层转储方案可以理解为常见的 tiered-leveled compaction 变种方案，L0 层是 size-tiered Compaction, 内部继续根据不同场景分裂多层，L1 和 L2 层基于宏块粒度来维持 Leveled compaction。

### L0 层

L0 层内部称为 Mini SSTable，根据不同转储策略需要的不同参数设置，L0 层 SSTable 可能存在可以为空。对于 L0 层提供 server 级配置参数来设置 L0 层内部分层数和每层最大 SSTable 个数，L0 层内部即分为level-0 到 level-n 层，每层最大容纳 SSTable 个数相同。当 L0 层 level-n 的 SSTable 到达一定数目上限或阈值后开始整体 compaction，合并成一个 SSTable 写入 level-n+1 层。当 L0 层 max level 内 SSTable 个数达到上限后，开始做 L0 层到 L1 层的整体 compaction 释放空间。在存在 L0 层的转储策略下，冻结 MemTable 直接转储在 L0-level0 写入一个新的 Mini SSTable，L0 层每个 level 内多个 SSTable 根据 base_version （这是一个用于标识 SSTable 版本的值）有序，后续本层或跨层合并时需要保持一个原则，参与合并的所有 SSTable 的 version 必须邻接，这样新合并后的 SSTable 之间仍然能维持 version 有序，简化后续读取合并逻辑。

L0 层内部分层会延缓到 L1 的 compaction，更好的降低写放大，但同时会带来读放大，假设共 n 层，每层最多 m 个 SSTable，则最差情况 L0 层会需要持有（n X m + 2）个 SSTable，包括 Minor SSTable 和 Major SSTable。因此实际应用中层数和每层 SSTable 上限都需要控制在合理范围。

### L1

L1 层内部称为 Minor SSTable，L1 层的 Minor SSTable 仍然维持 rowkey 有序，每当 L0 层 Mini SSTable 达到 compaction 阈值后，L1 层 Minor SSTable 开始参与和 L0 层的 compaction。为了尽可能提升 L1 Compaction 效率, 降低整体写放大, OceanBase 数据库内部提供写放大系数设置, 当 L0 层 Mini SSTable 总大小和 L1 Minor SSTable 大小比率达到指定阈值后, 才开始调度 L1 Compaction, 否则仍调度 L0 层内部 Compaction。

### L2

L2 层是基线 Major SSTable，为保持多副本间基线数据完全一致，日常转储过程中 Major SSTable 仍保持只读，不发生实际 compaction 动作。

## 转储触发

转储有两种触发方式：自动触发与手动触发。

当一个租户的 MemTable 内存的使用量达到 `memstore_limit_percentage * freeze_trigger_percentage` 所限制使用的值时，就会自动触发冻结（转储的前置动作），然后系统内部再调度转储。

您也可以通过以下的运维命令手动触发转储。

  <main id="notice" type='explain'>
    <h4>说明</h4>
    <p><code>memstore_limit_percentage</code> 用于设置租户使用 MemStore 的内存占其总可用内存的百分比。有关该配置项的详细介绍，请参见 <a href="../../../800.configuration-items-and-system-variables/100.system-configuration-items/300.cluster-level-configuration-items/13900.memstore_limit_percentage.md">memstore_limit_percentage</a>。</p>
  </main>

示例：

* 集群级别转储

  * 对 `sys` 租户发起的转储

    ```sql
    obclient> ALTER SYSTEM MINOR FREEZE TENANT = sys;
    ```

  * 对所有用户租户发起的转储

    ```sql
    obclient> ALTER SYSTEM MINOR FREEZE TENANT = all_user;
    ```

  * 对所有 META 租户发起的转储

    ```sql
    obclient> ALTER SYSTEM MINOR FREEZE TENANT = all_meta;
    ```

* 租户级别转储

    ```sql
    obclient> ALTER SYSTEM MINOR FREEZE TENANT= prod_tenant;
    ```

## 相关文档

更多转储操作请参见 [转储](../../../200.system-management/500.manage-data-storage/100.dump-management/100.dump-management-overview.md)。
