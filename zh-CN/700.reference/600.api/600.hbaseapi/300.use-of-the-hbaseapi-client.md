# OBKV-HBase 客户端使用介绍

本文从 OceanBase 的 OBKV-HBase 使用角度出发，引导您正确使用 OBKV-HBase 客户端。包括配置客户端、连接 OBserver，以及进行基本的增删改查操作。

## 背景信息

OBKV-HBase 客户端基于 OBKV-Table 提供的基本接口，在客户端封装了 HBase 兼容的 API，目前已兼容 HBase 0.94 版本的特性。
进行客户端操作前，需要了解下列 OceanBase 数据库的基本知识：

* [OBKV-HBase 方案介绍](../600.hbaseapi/100.introduction-to-hbaseapi-scheme.md)
* [快速体验 OceanBase 数据库](../../../200.quickstart/100.quickly-experience-oceanbase-for-community.md)
* [通过 MySQL 客户端连接 OceanBase 数据库](../../../300.develop/100.application-development-of-mysql-mode/100.connect-to-oceanbase-database-of-mysql-mode/200.connect-to-an-oceanbase-tenant-by-using-a-mysql-client-of-mysql-mode.md)

## OBKV-HBase 部署

### 添加客户端依赖

添加 OBKV-HBase 客户端 jar 包依赖到本地 java 工程的 pom.xml 文件（或参考 [OBKV-HBase 使用 Demo](https://github.com/oceanbase/obkv-hbase-client-java/tree/main/example/simple-hbase-demo)）。

```Java
<dependency>
    <groupId>com.oceanbase</groupId>
    <artifactId>obkv-hbase-client</artifactId>
    <version>0.1.4</version>
</dependency>
```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <ul><li>这里的版本号可能不是最新，参考<a href="[./4.replace-data-of-mysql-mode.md](https://mvnrepository.com/artifact/com.oceanbase/obkv-hbase-client)">中央仓库</a>的已发布 OBKV-HBase 版本，将版本号替换为已发布的最新版本号。</li>
  <li>尽量使用最新版本 jar 包，旧版本的 jar 包可能不支持新的服务端</li></ul>
</main>

### 建立 OB HBase 数据表

使用 OBClient 或 MySQL 连接 OBserver 集群，并建立 HBase 相关数据表，请参考 [OBKV-HBase 存储模型](../600.hbaseapi/200.hbaseapi-storage-models.md)。

### 客户端连接参数设置

OBKV-HBase 在公有云以及私有化部署方式各有不同，需要设置的客户端连接参数也不一样。如果你是私有化部署 OceanBase 集群，请参考直连模式配置，如果你是使用公有云 OBKV 服务，请参考云上模式。

#### 直连模式配置 (私有化部署)

##### Config URL 获取  (从 OCP 获取)

1. 登录 OceanBase 云平台。
2. 在左侧导航栏选择 **集群**，下滑找到**集群列表**。
3. 单击打开需要访问的集群名称。
4. 在集群详细信息页找到 **ConfigURL** 参数，该参数在客户端初始化中需要配置。

![获取 ConfigURL](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer/V3.1.3/zh-CN/Tools/TableAPI/oceanbase-doczh-CN-9.supporting-tools-8.hbaseapi-HBaseAPI%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D-01.png)

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>如果没有使用 OCP，参考 <a href="[../../../3.develop/1.application-development-of-mysql-mode/3.write-data-of-mysql-mode/4.replace-data-of-mysql-mode.md](https://www.oceanbase.com/docs/community-obd-cn-1000000000487083)">使用命令行部署 Config Server</a>， 并获取 ObRootServiceInfoUrl。</p>
</main>

##### OBKV-HBase 连接配置

```java
## 假设当前集群如下
## ClusterName：obkvcluster
## TenantName：obkv
## DataBaseName: test
## UserName：root
## SYS_USER_NAME : sysroot

#### 必选项
Configuration conf = new Configuration();

## 格式为 userName@tenantName#clusterName
conf.set(HBASE_OCEANBASE_FULL_USER_NAME, "root@obkv#obkvcluster");

## fullUserName 中 userName 访问 OceanBase 的密码
conf.set(HBASE_OCEANBASE_PASSWORD, "");

## 从 obconfig server 获取 RSlist 的 url，详见 Config URL 获取相关内容
conf.set(HBASE_OCEANBASE_PARAM_URL, "");

## 系统租户下的用户名, 只有系统租户下的用户才有权限访问路由表
conf.set(HBASE_OCEANBASE_SYS_USER_NAME, "sysroot");

## 系统租户下的用户密码
conf.set(HBASE_OCEANBASE_SYS_PASSWORD, "");

#### 可选项
## 执行请求的超时时间(基于业务特点选)，单位是 ms，如下表示超时时间 1s
conf.set("rpc.execute.timeout", "1000");
```

#### 云上模式配置 (公有云)

```java
## 假设当前集群如下
## DataBaseName: test
## UserName：root

#### 必选项
Configuration conf = new Configuration();

## 数据库新建的用户名，不用三段式，username
conf.set(HBASE_OCEANBASE_FULL_USER_NAME, "root");

## 用户 Password
conf.set(HBASE_OCEANBASE_PASSWORD, "");

## 详见 ODP Address 备注
conf.set(HBASE_OCEANBASE_ODP_ADDR, "");

## OBKV 的端口是 3307（固定）
conf.setInt(HBASE_OCEANBASE_ODP_PORT, "3307");

## 云上使用 ODP 模式(固定)
conf.setBoolean(HBASE_OCEANBASE_ODP_MODE, true);

## 数据库的database的名字
conf.set(HBASE_OCEANBASE_DATABASE, "test");

#### 可选项
## 执行请求的超时时间(基于自己业务特征配置)
conf.set("rpc.execute.timeout", "1000");
```

### 连接 OceanBas 集群

设置完客户端连接参数之后，我们开始初始化客户端，当前有两种不同方式：OHTableClient 和 OHTablePool，他们二者的区别如下：

* OHTableClient：非线程安全的, 内部只有一个 OHTable 句柄，多线程同时访问同一个 OHTable 会导致不可预估的问题（单线程场景使用）。

* OHTablePool：OHTable 池，需要的时候从池中获取对应表的 OHTable 实例使用（多线程场景使用）。

#### 通过 OHTable 连接

```java
// 设置 configuration，参考上一节，这里不展开
Configuration conf = new Configuration(); // 创建配置项
conf.set(xxx); //设置各个配置项
OHTableClient hTable = new OHTableClient("test1", conf); // 创建 htable对象
hTable.init(); // 初始化hTable
//执行相关逻辑
hTable.close(); //关闭htable对象
```

#### 通过 OHTablePool 连接

用法同 HBase 的 HTablePool，当需要某个 Table 的 HTable 时使用 `pool.getTable("xx")` 获取对应的 HTable, 需要注意的是:

* 参数使用优先级: Table 专用参数 (如 pool.setOdpAddr() 等) > Conf 设置的参数 > 默认参数。
* 使用完 HTable 后记得 close(), 将 OHTable 返还给 Pool, 推荐可以使用 try/finally 的方式返回 HTable。

```java
// 设置 configuration，参考上一节，这里不展开
Configuration conf = new Configuration(); // 创建配置项
conf.set(xxx);  //设置各个配置项

// 初始化 maxSize，用来表示 pool 中每张表的最大 htable 引用数
int maxSize = 100;
// 初始化 poolType，有 Reusable / ThreadLocal / RoundRobin 三种，推荐使用 ThreadLocal
PoolMap.PoolType poolType = PoolMap.PoolType.ThreadLocal;
OHTablePool pool = new OHTablePool(conf, maxSize, poolType);
HTableInterface hTable = pool.getTable("test"); // 获取对应表的hTable
//执行相关逻辑
hTable.close(); // retrun table to the pool
```

## OBKV-HBase 配置项

除了连接参数，我们可以通过 Configuration 设置一些其他的配置项，如下例中设置客户端的 RPC 超时时间为 3s：

```java
conf.set("rpc.execute.timeout", "3000");
```

### 常用配置项速查

| 配置项 | 含义 | 默认值 |
| --- | --- | --- |
| HBASE_OCEANBASE_FULL_USER_NAME | 用户名, 根据连接模式的不同可见[客户端连接参数设置](#客户端连接参数设置)章节 | 空 |
| HBASE_OCEANBASE_PASSWORD | 用户 Password | 空 |
| HBASE_OCEANBASE_PARAM_URL | 从 obconfig server 获取 RSlist 的 url | 空 |
| HBASE_OCEANBASE_SYS_USER_NAME | 系统租户下的用户名 | 空 |
| HBASE_OCEANBASE_SYS_PASSWORD | 系统租户下的用户密码 | 空 |
| HBASE_OCEANBASE_ODP_MODE | 是否使用云上配置 | False |
| HBASE_OCEANBASE_ODP_ADDR | ODP Address，详情见[客户端连接参数设置](#客户端连接参数设置)章节 | 空 |
| HBASE_OCEANBASE_ODP_PORT | ODP Port，详情见[客户端连接参数设置](#客户端连接参数设置)章节 | 空 |
| HBASE_OCEANBASE_DATABASE | 云上使用，数据库的 database 的名字 | 空 |
| `rpc.connect.timeout` | 建立RPC连接的超时时间，单位 ms | 1000ms |
| `rpc.execute.timeout` | 执行RPC请求的socket超时时间，单位 ms | 3000ms |
| `rpc.operation.timeout` | OceanBase 内部执行 RPC 请求的超时时间，单位 ms 建议和 rpc.execute.timeout 配置成一个值 | 10000ms |
| `metadata.refresh.interval` | 刷新METADATA的时间间隔，单位 ms | 60000ms |
| `runtime.continuous.failure.ceiling` | 连续运行失败上限，会刷新 TABLE 的信息 | 100 |
| `bolt.netty.buffer.low.watermark` | netty 写缓存的低水位 | 5*1024(512K) |
| `bolt.netty.buffer.high.watermark` | netty 写缓存的高水位 | 1024*1024(1M) |
| `runtime.retry.interval` | 运行出错重试的时间间隔 | 1 |
| `runtime.retry.times` | 运行出错重试的次数 | 1 |

### OHTable 配置

除了 Configuration，也可以通过 OHTable 的接口来设置单个 OHTable 的配置项：

| 接口 | 含义 | 默认值 |
| --- | --- | --- |
| `setAutoFlush()` | 设置 auto-flush | True |
| `setWriteBufferSize()` | 设置写缓冲区大小 | 2097152 Byte |

## 支持的 HBase 操作

按照上述步骤初始化完客户端之后，便可以开始执行操作，本章介绍了部分 OHTable 接口操作，如果想了解更多的接口信息，请参考：[OHTable.java](https://github.com/oceanbase/obkv-hbase-client-java/blob/main/src/main/java/com/alipay/oceanbase/hbase/OHTable.java)。
相关 OBKV-HBase 使用的 Demo 请参考：[OBKV-HBase 使用 Demo](https://github.com/oceanbase/obkv-hbase-client-java/tree/main/example/simple-hbase-demo)。

### Demo前的检查

* 创建 OBKV 的集群和相应租户。
* 在 OBKV 中创建 HBase 的表。
* 在 Java 工程的 POM.xml 中配置 OBKV-HBase 的依赖。
* 在 Java 代码中，配置 Configuration，并拿到 hTable 句柄。
* 通过 hTable 来执行如下数据访问操作。

### Put

函数说明：插入数据。
函数原型：

* void put(Put put)
* void put(List\<Put> puts)

参数列表：

* put：Put 对象，用于插入单条记录。
* puts：Put 对象集合，用于批量插入多条记录。

操作示例：

```Java
// 插入单条记录
String key = "testKey0";
String family = "family";
String column = "column";
String value = "putValue";
Put put = new Put(key.getBytes());
put.add(family.getBytes(), column.getBytes(), value.getBytes());
hTable.put(put);

// 插入多条记录
Put put1 = new Put(Bytes.toBytes("testKey1"));
put1.add(toBytes(family), toBytes(column), toBytes(value));
//put1.add(toBytes(family), toBytes(column), System.currentTimeMillis(), toBytes(value));

Put put2 = new Put(Bytes.toBytes("testKey2"));
put2.add(toBytes(family), toBytes(column), toBytes(value));
//put2.add(toBytes(family), toBytes(column), System.currentTimeMillis(), toBytes(value));
List<Put> puts = new ArrayList<Put>();
puts.add(put1);
puts.add(put2);
hTable.put(puts);
```

### Get

函数说明：获取指定行的数据。
函数原型：

* Result get(final Get get)
* Result[] get(List\<Get> gets)
  
参数列表：

* get：Get 对象，需要使用 addColumn 或 addFamily 来指定操作目标。
* gets：Get 对象列表，保存 Get 对象。

操作示例：

```Java
// 获取 one family
String key = "testKey0";
String family = "family";
int maxVersion = 1;
Get get = new Get(key.getBytes());
get.addFamily(family.getBytes());
get.setMaxVersions(maxVersion);
Result result = hTable.get(get);
if (result.list() != null) {
    System.out.printf("Get Demo: get cnt:%d%n", result.list().size());
}
```

### Scan

函数说明：根据指定条件（scan/family/qualifier）对 table 进行扫描。
函数原型：

* ResultScanner getScanner(byte[] family, byte[] qualifier)
* ResultScanner getScanner(final byte[] family)
* ResultScanner getScanner(final Scan scan)
  
参数列表：

* family：目标列簇，这里是指需要过滤的列簇。
* qualifier：目标列名，这里指需要过滤的列名。
* scan：Scan 对象，使用 addFamily 或 addColumn 等设置操作目标。

操作示例：

```Java
// 指定 scan
//注意 Hbase 0.94 的 start 和 endkey 是左闭右开，endkey 扫不到
String startKey = "testKey";
String endKey = "testKey9";
String family = "family";
String column = "column";
int maxVersion = 1;
Scan scan = new Scan();
scan.addColumn(family.getBytes(), column.getBytes());
scan.setMaxVersions(maxVersion);
scan.setStartRow(startKey.getBytes());
scan.setStopRow(endKey.getBytes());
ResultScanner scanner = hTable.getScanner(scan);
for (Result r : scanner) {
    for (KeyValue kv : r.list()) {
        System.out.printf("Scan Demo: Rowkey: %s, Column Family: %s, Column Qualifier: %s, Value: %s, Timestamp: %d%n",
                Bytes.toString(r.getRow()),
                Bytes.toString(kv.getFamily()),
                Bytes.toString(kv.getQualifier()),
                Bytes.toString(kv.getValue()),
                kv.getTimestamp());
    }
}
```

### Increment Column Value

函数说明：对表中的某行单列数据进行自增，执行成功则返回自增后的值，指定列的 cell 必须是 long 类型（64 字节整型）。
函数原型：

* long incrementColumnValue(byte[] row, byte[] family, byte[] qualifier, long amount, boolean writeToWAL)

参数列表：

* row：行键
* family：目标列簇，这里是建表时指定的列簇
* qualifier：目标列名
* amount：增加的数量（可以为负值）
* writeToWAL：是否预写日志（默认写入）

操作示例：

```Java
// 这里展示的是对单列自增 1
String column = "incrementColumn";
String key = "incrementKey";
String family = "family";
long increment_value = 1L;
long ret = hTable.incrementColumnValue(
        key.getBytes(),
        family.getBytes(),
        column.getBytes(),
        increment_value);
System.out.printf("Increment Column Demo: ret: %b%n", ret);
```

如果使用 Mysql 客户端查看 HBase 表，可能会发现对应 Cell 的 V 字段没有值，可以用 hex(v)来显示，如下：

```shell
MySQL [test]> select *,hex(v) from htable1$family;
+--------------+-----------------+----------------+----------+------------------+
| K            | Q               | T              | V        | hex(v)           |
+--------------+-----------------+----------------+----------+------------------+
| incrementKey | incrementColumn | -1715848789024 |          | 0000000000000001 |
+--------------+-----------------+----------------+----------+------------------+
```

### Increment

函数说明：对指定行中的单列或多列进行增加，指定列的 cell 必须是 long 类型（64 字节整型）。
函数原型：

* Result increment(Increment increment)
  
参数列表：

* increment： Increment 类型，需要使用 addColumn 进行属性设置。

操作示例：

```Java
// 这里展示的是对单列自增 1
String column = "incrementColumn";
String key = "incrementKey";
String family = "family";
long increment_value = 1L;
Increment increment = new Increment(key.getBytes());
increment.addColumn(family.getBytes(), column.getBytes(), increment_value);
Result r = hTable.increment(increment);

for (KeyValue kv : r.list()) {
    System.out.printf("Increment Demo: Rowkey: %s, Value:%s%n",
            Bytes.toString(r.getRow()),
            Bytes.toLong(kv.getValue()));
}
```

### Append

函数说明：对指定行中的单列或多列进行增加（针对字符类型，例如 byte，string 等）。
函数原型：

* Result append(Append append)
  
参数列表：

* append：Append 类型，需要使用 add 函数进行属性设置。

操作示例：

```Java
String column = "appendColumn";
String key = "appendKey";
String family = "family";
Append append = new Append(key.getBytes());
append.add(family.getBytes(), column.getBytes(), toBytes("_append"));
Result r = hTable.append(append);
for (KeyValue kv : r.list()) {
    System.out.printf("Appand Demo: Rowkey: %s, Append Value:%s%n",
            Bytes.toString(r.getRow()),
            Bytes.toString(kv.getValue()));
}
```

### Delete

函数说明：删除指定的存储单元（cells）或行（rows）。
函数原型：

* void delete(Delete delete)
* void delete(List\<Delete> deletes)
  
参数列表：

* deletes：Delete 对象，这里是指需要执行删除的行，通过 deleteFamily 函数设置。

操作示例：

```Java
// 如下是删除某 key，family，column 对应的行
String key = "testKey1";
String family = "family";
String column = "column";
Delete delete = new Delete(key.getBytes());
delete.deleteColumn(family.getBytes(),column.getBytes());
hTable.delete(delete);
```

### Exists

函数说明：判断在 Get 对象中设置的列簇或列是否存在，存在则返回 true，反之返回 false。
函数原型：

* boolean exists(Get get)
  
参数列表：

* get：Get 对象，使用 addFamily 或 addColumn 来设置操作目标。

操作示例：

```Java
String key = "testKey2";
String family = "family";
Get get = new Get(key.getBytes());
get.addFamily(family.getBytes());
boolean ret = hTable.exists(get);
System.out.printf("Exist Demo: ret: %b%n", ret);
```

### Check And Put

函数说明：检查并替换指定列数据，如果条件满足并替换成功，返回 true，反之返回 false。
函数原型：

* boolean checkAndPut(byte[] row, byte[] family, byte[] qualifier, byte[] value, Put put)
  
参数列表：

* row：目标行键
* family：目标列簇
* qualifier：目标列名
* value：目标列值
* put：需要替换的列值

操作示例：

```Java
String key = "testKey2";
String family = "family";
String column = "column";
String value = "putValue";
String new_value = "value_new";
Put put = new Put(key.getBytes());
put.add(family.getBytes(), column.getBytes(), new_value.getBytes());
boolean ret = hTable.checkAndPut(
        key.getBytes(),
        family.getBytes(),
        column.getBytes(),
        value.getBytes(),
        put);
System.out.printf("CheckAndPut Demo: ret: %b%n", ret);
```

### Check And Delete

函数说明：匹配删除列，若匹配条件符合并删除成功，返回 true，反之返回 false。
函数原型：

* boolean checkAndDelete(byte[] row, byte[] family, byte[] qualifier, byte[] value, Delete delete)
  
参数列表：

* row：目标匹配行键
* family：目标列簇，这里是建表时指定的列簇
* qualifier：目标匹配列名
* value：目标匹配列值
* delete：预期需要删除的列

操作示例：

```Java
String key = "testKey2";
String family = "family";
String column = "column";
String value = "value_new";
Delete delete = new Delete(key.getBytes());
delete.deleteColumn(family.getBytes(), column.getBytes());
boolean ret = hTable.checkAndDelete(
        key.getBytes(),
        family.getBytes(),
        column.getBytes(),
        value.getBytes(),
        delete);
System.out.printf("CheckAndDelete Demo: ret: %b%n", ret);
```

### Get Configuration

函数说明：返回操作实例中的 config 具柄，可用于在操作中变更属性。
函数原型：

* Configuration getConfiguration()
  
参数列表：

无

操作示例：

```Java
hTable.getConfiguration().set("rpc.execute.timeout", "1500");
```
