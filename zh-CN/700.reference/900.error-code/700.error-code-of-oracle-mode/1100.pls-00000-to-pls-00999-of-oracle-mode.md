
|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# PLS-00000 ~ PLS-00999

  <main id="notice" >
    <h4>功能适用性</h4>
    <p>该内容仅适用于 OceanBase 数据库企业版。OceanBase 数据库社区版仅提供 MySQL 模式。</p>
  </main>

## PLS-00001：PL/SQL common error", "%s

* OceanBase 错误码：9656

* SQLSTATE：HY000

* 错误原因：出现非预期的符号。

* 解决方式：报错的位置出现的符号是非预期的，修改报错位置出现的符号。

## PLS-00103：Encountered the symbol %s when expecting one of the following: %s

* OceanBase 错误码：9700

* SQLSTATE：HY000

* 错误原因：解析器发现了一个在此上下文中不合适的标记。

* 解决方式：检查以前的令牌以及错误消息中给出的令牌。错误消息中给出的行号和列号表示错误语言结构的结尾所在位置。

## PLS-00109：unknown exception name '%.\*s' in PRAGMA EXCEPTION_INIT

* OceanBase 错误码：9583

* SQLSTATE：HY000

* 错误原因：在编译指示的范围内没有找到在 `EXCEPTION_INIT` 编译指示中引用的异常名称的声明。

* 解决方式：确保 `pragma` 遵循异常声明并且在同一范围内

## PLS-00113：END identifier '%.\*s' must match '%.\*s

* OceanBase 错误码：9659

* SQLSTATE：HY000

* 错误原因：关键字 `END` 终止了一些语言构造（如：循环、块、函数和过程），在此之后您可以选择放置该构造的名称。例如，在循环 `L` 定义的末尾，您可能会写入 `END L`。当可选名称与给定给语言构造的名称不匹配时，就会发生此错误。它通常是由拼写错误的标识符或错误的块结构引起的。

* 解决方法：确保结束标识符的拼写与指定给语言结构的名称匹配，并且块结构正确。

## PLS-00114：identifier ' %.\*s' too long

* OceanBase 错误码：9526

* SQLSTATE：HY000

* 错误原因：PL 变量的名称超过 128 个字符。合法标识符（包括带引号的标识符）的最大长度为 128 个字符。可能是由于字符串文字可能被错误地用双引号而不是单引号引起来，在这种情况下，PL 将其视为带引号的标识符。

* 解决方法：缩短标识符。

## PLS-00115：this PRAGMA must follow the declaration of '%.\*s

* OceanBase 错误码：9622

* SQLSTATE：HY000

* 错误原因：`pragma` 指的是未声明或不在引用范围内的 PL/SQL 对象。标识符在 `pragma` 中使用之前必须声明；不允许转发引用。

* 解决方法：检查标识符的拼写和声明。还要确认声明已正确放置在块结构中。

## PLS-00119：Duplicate having-clause in table expression

* OceanBase 错误码：9501

* SQLSTATE：HY000

* 错误原因：在 `SELECT` 语句中找到两个或多个 `HAVING` 子句。

* 解决方法：删除一个 `HAVING` 子句，并在必要时通过 `AND` 或 `OR` 连接逻辑表达式。

## PLS-00124：name of exception expected for first arg in exception_init pragma

* OceanBase 错误码：9674

* SQLSTATE：HY000

* 错误原因：传递给异常 `exception_init` pragma 的第一个参数是不是异常名称。

* 解决方法：用合法声明的异常名称替换第一个参数。

## PLS-00128：Illegal number of arguments for pragma EXCEPTION_INIT

* OceanBase 错误码：9675

* SQLSTATE：HY000

* 错误原因：传递给命名 `pragma` 的参数（实际参数）的数量（编译器指令）不正确。参数列表中省略了必需的参数，或者 `pragma` 语法有错误（例如，两个参数之间可能缺少逗号）。

* 解决方法：提供缺少的参数，或更正错误的语法。

## PLS-00130：Pragma %s expects 1st argument to be a procedure/function/package/cursor

* OceanBase 错误码：9661

* SQLSTATE：HY000

* 错误原因：根据需要，传递给命名 `pragma`（编译器指令）的第一个参数（实际参数）不是子程序、包或游标的名称。参数可能拼写错误，或者 `pragma` 语法可能有错误（例如，两个参数之间可能缺少逗号）。

* 解决方法：检查第一个参数的拼写，并确保使用了正确的语法。

## PLS-00132：Pragma %s does not support %.\*s

* OceanBase 错误码：9658

* SQLSTATE：HY000

* 错误原因：传递给此 `pragma` 的参数之一不在允许值列表中。参数可能拼写错误，或者 `pragma` 语法可能有错误（例如，两个参数之间可能缺少逗号）。

* 解决方法：检查所有参数的拼写，确保使用了正确的语法。

## PLS-00154：An object type may have only 1 MAP or 1 ORDER method

* OceanBase 错误码：9523

* SQLSTATE：HY000

* 错误原因：声明了多个 `MAP` 或 `ORDER` 函数。一个对象类型只能具有一个 `MAP` 函数或 `ORDER` 函数，不能有多个 `MAP` 函数，也不能有多个 `ORDER` 函数，并且不能同时具有两者。

## PLS-00155：Only a function may be a MAP, ORDER or CONSTRUCTOR method

* OceanBase 错误码：9525

* SQLSTATE：HY000

* 错误原因：过程被声明为 `MAP` 、`ORDER` 或 `CONSTRUCTOR` 方法。仅函数可以是 `MAP` 、`ORDER` 或 `CONSTRUCTOR` 方法。

## PLS-00157：Only schema-level programs

allow %s

* OceanBase 错误码：9506

* SQLSTATE：HY000

* 错误原因：为程序包或类型指定了 `AUTHID` 或 `DEFAULT COLLATION` 子句。仅模式级别存储过程、程序包和类型才支持这些子句。

* 解决方法：删除子句。

## PLS-00168：string'", "duplicate modifier specification '%s'

* OceanBase 错误码：9643

* SQLSTATE：HY000

* 错误原因：多次指定了方法或对象类型修改器。

* 解决方法：删除除一次之外的所有重复修改器。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00169：modifier '%s' conflicts with prior '%s' specification

* OceanBase 错误码：9642

* SQLSTATE：HY000

* 错误原因：指定的方法或对象类型修饰符与以前的修饰符冲突。例如，最终修改器不能与非最终修改器组合。

* 解决方法：删除一个冲突的修饰符。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00172：string literal too long

* OceanBase 错误码：9644

* SQLSTATE：HY000

* 错误原因：字符串文字长度超过 32767 字节。

* 解决方法：使用最多 32767 字节的字符串文字。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00179：$ERROR: %.\*s

* OceanBase 错误码：9540

* SQLSTATE：HY000

* 错误原因：使用了 `$ERROR` 指令。

## PLS-00182: Identifier cannot be an empty string

* OceanBase 错误码：9657

* SQLSTATE：HY000

* 错误原因：标识符是使用空字符串声明的。

* 解决方法：将标识符重命名为非空字符串。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00201: identifier '%.\*s' must be declared

* OceanBase 错误码：5543，5546

* SQLSTATE：42000

* 错误原因：

  * 引用未声明的变量、异常程序、过程。

  * 引用未授予权限的类型。

  * 引用仅通过角色授予权限的类型。

  * 存储的对象（程序包、过程、函数、触发器、视图）在对象所有者的安全域中运行，除了 `PUBLIC` 之外，没有启用任何角色。

* 解决方法：

  * 检查您的引用名称的拼写和声明。

  * 验证所引用项的声明是否正确放置在块结构中。

  * 如果确实声明了所引用的项目，并且您认为自己有权引用该项目，请检查权限。

## PLS-00204：function or pseudo-column '%s' may be used inside a SQL statement only

* OceanBase 错误码：9682

* SQLSTATE：HY000

* 错误原因：程序语句中使用了伪列或禁止的函数。SQL 伪列（ LEVEL、ROWID、ROWNUM ）只能在 SQL 中使用声明。类似地，某些函数（如：DECODE、DUMP 和 VSIZE ）和 SQL 组函数（平均值、最小值、最大值、计数、总和、STDEV、方差）可以仅在 SQL 语句中使用。

* 解决方法：从程序中删除伪列引用或函数调用陈述。或者，将程序语句替换为 SELECT INTO 语句。例如，用 `SELECT DECODE(rating, 1, 5000, 2, 2500, ...) INTO bonus FROM dual;` 描述替换 `bonus := DECODE(rating, 1, 5000, 2, 2500, ...);`。

## PLS-00206：%%TYPE must be applied to a variable, column, field or attribute, not to '%.\*s'

* OceanBase 错误码：9547

* SQLSTATE：HY000

* 错误原因：使用 `％TYPE` 数据类型属性声明的程序对象不是合适的类型，该类型必须是变量、列、记录组属性，子程序形式参数或其它可以赋值的对象。

* 解决方法：在变量声明中添加一个初始化子句。如果初始化的语法过于复杂，则可以添加一个函数调用。

## PLS-00218：a variable declared NOT NULL must have an initialization assignment

* OceanBase 错误码：9514

* SQLSTATE：HY000

* 错误原因：通常，声明中没有初始化子句的变量会自动初始化为 `NULL`。这对于 `NOT NULL` 变量是不合逻辑的。因此，需要一个初始化子句。

* 解决方法：在变量声明中添加一个初始化子句。如果初始化的语法过于复杂，则可以添加一个函数调用。

## PLS-00221：%s' is not a procedure or is undefined

* OceanBase 错误码：9683

* SQLSTATE：HY000

* 错误原因：作为过程引用的标识符未声明或实际上代表另一个对象（例如，它可能已声明为函数）。

* 解决方法：检查标识符的拼写和声明。还要确认声明已正确放置在块结构中。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00222：no function with name '%.\*s' exists in this scope

* OceanBase 错误码：9627

* SQLSTATE：HY000

* 错误原因：被引用为函数的标识符未被声明或实际代表其他对象（例如，它可能已被声明为过程）。

* 解决方法：检查标识符的拼写和声明。还要确认声明已正确放置在块结构中。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00225：subprogram or cursor '%.\*s' reference is out of scope

* OceanBase 错误码：9628

* SQLSTATE：HY000

* 错误原因：限定名中的前缀是不在封闭范围内的子程序或游标；即，子程序或游标名称被用作范围限定符，以引用不在范围内的实体（在该子程序或游标内）。示例：`declare x number; type t1 is record (a number); function f return t1 is a number; begin x := f.a;`：

  * 合法使用函数"f"作为范围限定符

    * 在 `x := f().a;` 函数中解析局部变量"a"

    * 对返回记录端的组件"a"的合法引用；

  * 非法使用函数"f"作为范围限定符 `x :=f().a;`，对返回记录端的组件"a"的合法引用

* 解决方法：

  * 如果意图是引用非封闭函数的局部变量，则不允许这样做，删除引用。

  * 如果这是一个无参数函数，并且目的是访​​问对该函数的调用结果的字段，则在调用中使用空括号。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00227：subprogram 'in' formal %.\*s is not yet denotable

* OceanBase 错误码：9598

* SQLSTATE：HY000

* 错误原因：当一个子程序的形式参数被声明时，一个参数被用来初始化另一个参数，如：`PROCEDURE my_proc (j NUMBER, k NUMBER := j) IS ...`。第一个参数在运行时之前没有值，因此不能用于初始化另一个参数。

* 解决方法：删除非法的形式参数引用。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00230：OUT and IN OUT formal parameters may not have default expressions

* OceanBase 错误码：9599

* SQLSTATE：HY000

* 错误原因：声明过程的形式参数时，`OUT` 或 `IN-OUT` 参数被初始化为默认值，如：`PROCEDURE calc_bonus (bonus OUT REAL := 0, ...) IS ...`。但是，只有 `IN` 参数可以初始化为默认值。

* 解决方法：删除非法的默认表达式。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00231：function '%.\*s' may not be used in SQL

* OceanBase 错误码：9668

* SQLSTATE：HY000

* 错误原因：SQL 语句中使用了一个被禁止的函数。某些函数，如 `SQLCODE` 和 `SQLERRM`，只能在过程语句中使用。

* 解决方法：从 SQL 语句中删除函数调用。或者用局部变量替换函数调用。例如，以下语句是非法的：`INSERT INTO errors VALUES（SQLCODE，SQLERRM）；` 但您可以将 `SQLCODE` 和 `SQLERRM` 的值分配给局部变量，然后使用 SQL 语句中的变量，如下所示：`err_num:=SQLCODE；err_msg:=SQLERRM；` 插入错误值 `（err_num、err_msg）；`。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00254：OUT and IN/OUT modes cannot

be used in this context

* OceanBase 错误码：9502

* SQLSTATE：HY000

* 错误原因：`USING` 子句未正确使用实际参数模式（`OUT` 或 `IN/OUT` ）。对于 `OPEN` 语句中的 `USING` 子句，仅允许 `IN` 模式。

* 解决方法：将 `USING` 子句中的参数模式更改为正确的模式。

## PLS-00263：mismatch between string on a subprogram specification and body

* OceanBase 错误码：9602

* SQLSTATE：HY000

* 错误原因：对于在包装规范中没有等效条款的项目，在包装正文中指定了 `ACCESSIBLE BY` 子句。在包体中，只能在外部可见的子程序上指定此子句，并且子程序规范和包体必须具有等效的子句。不能在包本地或嵌套子程序上指定此子句。

* 解决方法：修改子程序体上的条款，以符合规范错误，直到为外部程序预留 300 个 PH2 错误。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00301：Invalid GOTO to non-label '%.\*s'

* OceanBase 错误码：9667

* SQLSTATE：HY000

* 错误原因：`GOTO` 语句转到非标签的内容（如：变量）。

* 解决方法：指定有效的标签名称。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00302：component '%.\*s' must be declared

* OceanBase 错误码：9681

* SQLSTATE：HY000

* 错误原因：在对组件的引用中（例如，在名称"a.B"中，"B"是"a"的组件），该组件尚未声明。组件可能拼写错误，其声明可能有错误，或者声明可能在块结构中放置不正确。

* 解决方法：检查组件的拼写和声明。还要确认声明已正确放置在块结构中。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00304：cannot compile body of

'%.\*s' without its specification

* OceanBase 错误码：9520

* SQLSTATE：HY000

* 错误原因：找不到编译程序包主体所需的编译程序包规范。可能原因如下：

  * 软件包名称拼写错误。

  * 从未编译过软件包规范。

  * 无法访问已编译的程序包规范。软件包规范必须在编译软件包主体之前进行编译，并且编译器必须有权访问已编译的规范。

* 解决方法：

  * 检查软件包名称的拼写。

  * 在编译程序包主体之前，请先编译程序包规范。

  * 请确保编译器可以访问已编译的规范。

## PLS-00305：previous use of '%.\*s'

conflicts with this use

* OceanBase 错误码：9529

* SQLSTATE：HY000

* 错误原因：在查找游标、过程、函数或程序包的预声明时，编译器在同一作用域中找到了另一个具有相同名称的对象。或者，程序包子程序的头部中的名称和主体中的名称不匹配。

* 解决方法：

  1. 检查游标、过程、函数的拼写及程序包名称。

  2. 检查在同一作用域中声明的所有常量、变量、参数和异常的名称。

  3. 删除或重命名具有重复名称的对象。

  4. 修改子程序头部中的名称，使其与程序主体中的名称相匹配。

## PLS-00306：wrong number or types of arguments in call to '%.\*s'

* OceanBase 错误码：9542

* SQLSTATE：HY000

* 错误原因：当子程序的调用无法与该子程序名称的任何声明匹配时，将会报此错误码。有以下几种情况：

  * 子程序名称可能拼写错误。

  * 参数可能具有错误的数据类型。

  * 声明可能有误或声明可能被错误地放置在块结构中。例如，以拼写错误的名称或者数据类型错误的参数调用内置的平方根函数 `SQRT`。

* 解决方式：

  * 检查子程序名称的拼写和声明。

  * 确认它的调用是正确的。

  * 确认参数是正确的数据类型。

  * 如果不是内置的函数，则将声明正确放置在块结构中。

## PLS-00307：too many declarations of '%.\*s' match this call

* OceanBase 错误码：9544

* SQLSTATE：HY000

* 错误原因：子程序或游标名称的声明是模棱两可的，因为在使用参数数据类型的隐式转换时，声明和调用之间没有完全匹配，并且有多个声明与调用匹配。可能存在以下原因：

  * 子程序或游标名称可能拼写错误。

  * 声明可能有误。

  * 声明可能未正确地放置在块结构中。

* 解决方式：

  * 检查子程序或游标名的拼写和声明。

  * 确认调用正确。

  * 确认参数具有正确的数据类型。

  * 如果不是内置函数，则将声明正确放置在块结构中。

## PLS-00310：with %%ROWTYPE attribute, '%.\*s' must name a table, cursor or cursor-variable

* OceanBase 错误码：9586

* SQLSTATE：HY000

* 错误原因：`%ROWTYPE` 属性必须应用于声明为游标、游标变量或数据库表的标识符。当 `%ROWTYPE` 跟在某个尚未声明的标识符后面时，会发生此错误。

* 解决方式：更改声明或不对标识符应用 `%ROWTYPE` 属性。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00312：a positional parameter association may not follow a named association

* OceanBase 错误码：9653

* SQLSTATE：HY000

* 错误原因：将参数列表传递给子程序或游标时，如果同时使用位置关联和命名关联，则所有位置关联都必须按其声明的顺序放置在所有命名关联之前，可以是任何顺序。

* 解决方式：重新排序参数列表以满足要求或仅使用命名关联。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00315：Implementation restriction: unsupported table index type

* OceanBase 错误码：9610

* SQLSTATE：HY000

* 错误原因：在 PL/SQL 表声明的 `INDEX BY` 子句中，指定了除 BINARY_INTEGER、PLS_INTEGER 或 VARCHAR2 之外的数据类型。PL/SQL 表可以有一列和一个主键。列可以有任何标量类型，但主键必须是二进制整数类型或 VARCHAR2。

* 解决方式：在 `INDEX BY` 子句中使用受支持的键类型之一。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00316：PL/SQL TABLEs must use a single index

* OceanBase 错误码：9631

* SQLSTATE：HY000

* 错误原因：在 PL/SQL 表声明的 `INDEX BY` 子句中，指定了复合主键。PL/SQL 表必须具有二进制整数或 VARCHAR2 类型的简单未命名主键。

* 解决方式：在 `INDEX BY` 子句中使用受支持的键类型之一。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00318：type '%.\*s' is malformed because it is a non-REF mutually recursive

type

* OceanBase 错误码：9539

* SQLSTATE：HY000

* 错误原因：类型声明的格式错误，因为申明中包含了相互递归的非 REF 关系。可能为以下情况：

  * 包含递归自引用

  * 包含相互递归引用

* 解决方式：在声明中使用其他类型避免递归。

## PLS-00320：the declaration of the type of this expression is incomplete or malformed

* OceanBase 错误码：9597

* SQLSTATE：HY000

* 错误原因：在声明中，变量或游标的名称拼写错误，或者声明中包含前向引用。PL/SQL 中不允许前向引用。变量或游标必须先声明，然后才能在其他语句（包括其他声明性语句）中引用。例如：`dept_rec` 的声明会引发此异常，因为它引用了尚未声明的游标 `dept_cur`。示例如下：

  ```unknow
  DECLARE dept_rec dept_cur%ROWTYPE; 
  CURSOR dept_cur IS SELECT ...
  ```

* 解决方法：检查声明中所有标识符的拼写。如有必要，移动声明的位置，消除前向引用。

## PLS-00321：expression '%.\*s' is

inappropriate as the left hand side of anassignment statement

* OceanBase 错误码：9513

* SQLSTATE：HY000

* 错误原因：该表达式不能出现在赋值语句的左侧。例如，函数 `SYSDATE` 不能出现在赋值语句的左侧，例如 `SYSDATE：= '01 -JAN-1990';`。

* 解决方法：修改不正确的赋值语句。

## PLS-00322：declaration of a constant '%.\*s' must contain an initialization assignment

* OceanBase 错误码：9515

* SQLSTATE：HY000

* 错误原因：常量声明缺少初始值。

* 解决方法：更正常量声明。

## PLS-00323：subprogram or cursor '%.\*s' is declared in a package specification and must be defined in the package body

* OceanBase 错误码：9585

* SQLSTATE：HY000

* 错误原因：在包头中声明的游标或者子过程，必须在包体中定义。

* 解决方法：检查子程序名称的拼写。如有必要，添加缺少的子程序体到包体。

## PLS-00325：non-integral numeric literal %.\*s is inappropriate in this context

* OceanBase 错误码：9605、9670

* SQLSTATE：HY000

* 错误原因：在需要整数的上下文中使用了非整数数字文本。

* 解决方法：用整数文本替换不合适的文本。

## PLS-00328：A subprogram body must be defined for the forward declaration of %.\*s

* OceanBase 错误码：9587

* SQLSTATE：HY000

* 错误原因：已声明子程序规范，但未定义相应的子程序体。将子程序规范和正文作为一个单元编写。另一种解决方案是将规范与其主体分离，这在您想要定义相互递归的子程序或想要将子程序分组到包中时是必要的。

* 解决方法：检查子程序名称的拼写。如有必要，提供缺失的子程序体。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00329：schema-level type has illegal reference to %.\*s

* OceanBase 错误码：9609

* SQLSTATE：HY000

* 错误原因：从 schema 级别类型引用到 schema 级别类型以外的其他类型。

* 解决方法：替换非法引用，然后重试该操作。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00357：Table,View Or Sequence reference '%s%s%s%s%s' not allowed in this context

* OceanBase 错误码：9680

* SQLSTATE：HY000

* 错误原因：在不适当的上下文中找到对数据库表、视图或序列的引用。此类引用只能出现在SQL语句中，或者（不包括序列）出现在 `%TYPE` 和 `%ROWTYPE` 声明中。下面是一些有效的例子：`SELECT ename, emp.deptno, dname INTO my_ename, my_deptno, my_dept .FROM emp, dept WHERE emp.deptno = dept.deptno; DECLARE last_name emp.ename %TYPE; dept_rec dept%ROWTYPE;`。

* 解决方法：删除或重新定位非法引用。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00360：cursor declaration without body needs return type

* OceanBase 错误码：9595

* SQLSTATE：HY000

* 错误原因：游标声明缺少主体（ `SELECT` 语句）或返回类型。如果要将游标规范与其主体分离，则必须提供返回类型，如：`CURSOR c1 RETURN emp%ROWTYPE;`。

* 解决方法：向游标声明中添加 `SELECT` 语句或返回类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00361：IN cursor '%.\*s' cannot be OPEN'ed

* OceanBase 错误码：9594

* SQLSTATE：HY000

* 错误原因：无法修改模式为的游标参数，因此无法打开。

* 解决方法：将光标参数更改为 `IN-OUT` 或 `OUT`。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00362：invalid cursor return type; '%.\*s' must be a record type

* OceanBase 错误码：9593

* SQLSTATE：HY000

* 错误原因：在游标规范或 REF 游标类型定义中，非记录类型（如：NUMBER 或 TABLE）被指定为返回类型。这是不允许的。只允许以下返回类型：`<record_type_name><record_name>%type<table_name>%ROWTYPE<cursor_name>%ROWTYPE<cursor_variable_name>%ROWTYTPE`。

* 解决方法：修改游标规范或引用游标类型定义，使其指定上述返回类型之一。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00363：expression '%.\*s' cannot be used as an assignment

* OceanBase 错误码：9550

* SQLSTATE：HY000

* 错误原因：在语句中，错误的使用了文字、常量、`IN` 参数、LOOP 中的 `counter` 变量或函数调用。

* 解决方法：更改语句表达式。

## PLS-00366：subtype of a not null type must also be not null

* OceanBase 错误码：9684

* SQLSTATE：HY000

* 错误原因：子类型定义为 `NOT NULL` 后，不允许它被用作另一个定义为 `NULL` 的子类型的基类型。例如：`DECLARE SUBTYPE Weekday IS INTEGER NOT NULL; SUBTYPE Weekend IS Weekday;`。

* 解决方法：修改子类型定义以消除冲突。

## PLS-00367：a RAISE statement with no exception name must be inside an exception handler

* OceanBase 错误码：9592

* SQLSTATE：HY000

* 错误原因：在异常处理程序之外发现了一个不跟异常名称的 RAISE 语句。

* 解决方法：删除 RAISE 语句，将其重新定位到异常处理程序，或提供缺少的异常名称。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V3.2.4 版本开始引入。</p>
</main>

## PLS-00369：no choices may appear with choice OTHERS in an exception handler

* OceanBase 错误码：9596

* SQLSTATE：HY000

* 错误原因：在异常处理程序的定义中遇到 `WHEN excep1 OR OTHERS` 形式的表单构造。`OTHERS` 处理程序必须作为块中的最后一个异常处理程序单独出现。

* 解决方法：删除与其他标识符一起出现的标识符，或为该标识符编写单独的异常处理程序。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00370：OTHERS handler must be last among the exception handlers of a block

* OceanBase 错误码：9591

* SQLSTATE：HY000

* 错误原因：一个或多个异常处理程序出现在其他处理程序之后。`OTHERS` 处理程序必须是块或子程序中的最后一个处理程序，因为它充当所有未具体命名的异常的处理程序。

* 解决方法：移动 `OTHERS` 处理程序，使其遵循所有特定的异常处理程序。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00371：at most one declaration for

'%.\*s' is permitted

* OceanBase 错误码：9507

* SQLSTATE：HY000

* 错误原因：对变量的引用是模糊的，因为该变量有多个声明。在块、过程或函数的声明部分，最多允许一个具有给定标识符的局部变量。给定的变量最多可以出现在一个块中。

* 解决方法：检查变量的拼写。如有必要，请删除变量的所有声明，仅保留一个声明。

## PLS-00372：In a procedure, RETURN statement cannot contain an expression

* OceanBase 错误码：5583

* SQLSTATE：42000

* 错误原因：在过程中，`RETURN` 语句包含不允许包含表达式。

* 解决方法：从 `RETURN` 语句中删除表达式，或将过程重新定义为函数。

## PLS-00373：EXIT/CONTINUE label '%.\*s'

must label a LOOP statement

* OceanBase 错误码：9512

* SQLSTATE：HY000

* 错误原因：`EXIT` 或 `CONTINUE` 语句中的标签未引用 `LOOP` 语句。`EXIT` 或 `CONTINUE` 语句无需指定标签，如果指定了标签（如 `EXIT my_label` 或 `CONTINUE my_label` 中的标签），则标签必须引用 `LOOP` 语句。

* 解决方法：确保标签名称的拼写正确，并且引用了 `LOOP` 语句。

## PLS-00375：illegal GOTO statement; this GOTO cannot branch to label '%.\*s'

* OceanBase 错误码：9505

* SQLSTATE：HY000

* 错误原因：`GOTO` 语句的分支是从包含语句序列的结构体（例如，循环或异常处理程序）外部到语句序列内的标签。这样的分支是不允许的。

* 解决方式：将 `GOTO` 语句移到语句序列内或将带标签的语句移到语句序列外。

## PLS-00376：illegal EXIT/CONTINUE

statement; it must appear inside a loop

* OceanBase 错误码：9510

* SQLSTATE：HY000

* 错误原因：在循环结构体之外找到了 `EXIT` 或 `CONTINUE` 语句。`EXIT` 语句从循环中过早退出，而 `CONTINUE` 语句用于开始循环的下一个迭代。这两个语句必须始终出现在循环中。

* 解决方法：删除 `EXIT` 或 `CONTINUE` 语句，或将其放入循环结构体中。

## PLS-00382：expression is of wrong type

* OceanBase 错误码：9519

* SQLSTATE：HY000

* 错误原因：表达式具有错误的数据类型。

* 解决方法：更改表达式的数据类型。您可能要使用数据类型转换功能。

## PLS-00386：type mismatch found at '%.\*s' between FETCH cursor and INTO variables

* OceanBase 错误码：9590

* SQLSTATE：HY000

* 错误原因：`FETCH` 语句的 `INTO` 列表中的赋值目标在数据类型上与游标声明的 select 列表中的相应列不匹配，并且不清楚需要哪种隐式转换来纠正不匹配。

* 解决方法：更改游标声明或更改分配目标的数据类型。您可能希望在与游标关联的查询的选择列表中使用数据类型转换函数。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00394：wrong number of values in the INTO list of a FETCH statement

* OceanBase 错误码：9660

* SQLSTATE：HY000

* 错误原因：`FETCH` 语句的 `INTO` 子句中的变量数与游标声明中的列数不匹配。

* 解决方法：更改 `INTO` 子句中的变量数或游标声明中的列数，以便数字匹配。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00402：alias required in SELECT list of cursor to avoid duplicate column names

* OceanBase 错误码：9588

* SQLSTATE：HY000

* 错误原因：游标是用包含重复列名的 `SELECT` 语句声明的。

* 解决方法：用别名替换"选择"列表中重复的列名。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00403：expression '%.\*s' cannot be used as an INTO-target of a SELECT/FETCH statement

* OceanBase 错误码：9665

* SQLSTATE：HY000

* 错误原因：`FETCH` 语句无法为赋值目标赋值它的 `INTO` 列表，因为目标不是合法形成和声明的变量。例如：以下赋值是非法的，因为 `'Jones'` 是一个字符串，而不是一个变量：`FETCH my_cur INTO 'Jones'`。

* 解决方法：检查分配目标的拼写和声明。确保遵循形成变量名称的规则。

## PLS-00404：cursor '%.*s' must be declared with FOR UPDATE to use with CURRENT OF

* OceanBase 错误码：9693

* SQLSTATE：HY000

* 错误原因：`CURRENT OF cursor_name` 子句中 `cursor_name` 没有在 `FOR UPDATE` 子句中声明过。

* 解决方法：在游标定义中添加 `FOR UPDATE` 子句或不使用 `CURRENT OF cursor_name` 子句。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V3.2.4 版本开始引入。</p>
</main>

## PLS-00410：duplicate fields in

RECORD,TABLE or argument list are not permitted

* OceanBase 错误码：9508

* SQLSTATE：HY000

* 错误原因：声明用户定义的记录时，两个字段具有相同的名称。与数据库表中的列名一样，用户定义的字段名必须唯一。

* 解决方法：检查字段名称的拼写，然后删除重复的名称。

## PLS-00413：identifier in CURRENT OF clause is not a cursor name

* OceanBase 错误码：9692

* SQLSTATE：HY000

* 错误原因：`CURRENT OF` 子句中的标识符命名是一个对象而不是游标。

* 解决方法：检查标识符的拼写。确保该标识符在 `DELETE` 或 `UPDATE` 语句中的命名是游标，并且命名的是游标本身，而不是 FOR 循环变量。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V3.2.4 版本开始引入。</p>
</main>

## PLS-00428：an INTO clause is expected in this SELECT statement

* OceanBase 错误码：9618

* SQLSTATE：HY000

* 错误原因：`SELECT INTO` 语句的 `INTO` 子句被省略。例如，代码类似 `SELECT deptno, dname, loc FROM dept WHERE ... instead of SELECT deptno, dname, loc INTO dept_rec FROM dept WHERE ...`。在 PL/SQL 中，只有子查询没有 `INTO` 子句。

* 解决方法：添加 `required INTO` 子句。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00430：FORALL iteration variable %.\*s is not allowed in this context

* OceanBase 错误码：9612

* SQLSTATE：HY000

* 错误原因：`FORALL` 迭代变量只能用作下标。它不能直接使用，也不能作为表达式的一部分使用。

* 解决方法：仅将 `FORALL` 变量用作集合下标。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00432：implementation restriction: cannot use FORALL and BULK COLLECT INTO together in SELECT statements

* OceanBase 错误码：9614

* SQLSTATE：HY000

* 错误原因：`SELECT` 语句包含 `FORALL` 和 `BULK COLLET INTO` 短语。

* 解决方法：不能在 `SELECT` 语句中同时使用 `FORALL` 和 `BULK COLLET INTO` 短语。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00435：DML statement without BULK In-BIND cannot be used inside FORALL

* OceanBase 错误码：9615

* SQLSTATE：HY000

* 错误原因：`FORALL` 语句中的 DML（ `SELECT/INSERT/DELETE/UPDATE` ）语句不包含 `BULK IN-BIND` 变量。

* 解决方法：`FORALL` 语句中的 DML（ `SELECT/INSERT/DELETE/UPDATE` ）语句必须包含 `BULK IN-BIND` 变量。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00438：value in LIMIT clause

\\'%.\*s\\' use is invalid

* OceanBase 错误码：9518

* SQLSTATE：HY000

* 错误原因：`FETCH INTO` 后的 `LIMIT` 子句的数值类型不对。例如下面的语句是非法的，因为 `LIMIT` 子句需要一个数字值。`FETCH c1 BULK COLLECT INTO var_tab LIMIT 'aaaaa';`。

* 解决方法：修改 `LIMIT` 子句的表达式使其后面是个数字值。如 `FETCH c1 BULK COLLECT INTO
  var_tab LIMIT '22333';`。

## PLS-00439：A LIMIT clause must be used within a BULK FETCH

* OceanBase 错误码：9636

* SQLSTATE：HY000

* 错误原因：在非批量获取中使用 `LIMIT` 子句。

* 解决方法：当使用非批量提取时，不要使用 `LIMIT` 子句。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00441：EXIT/CONTINUE statement may have a label here; '%.\*s' is not a label

* OceanBase 错误码：9654

* SQLSTATE：HY000

* 错误原因：指定的名称不是标签。`EXIT` 或 `CONTINUE` 语句不需要标签，但当出现可选名称时，它必须是标签。

* 解决方法：检查名字的拼写。确保名称是嵌套 `EXIT` 或 `CONTINUE` 语句的循环的标签。如果此语句不需要标签，请删除名称。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00452：Subprogram '%.\*s' violates its associated pragma

* OceanBase 错误码：9619

* SQLSTATE：HY000

* 错误原因：不能从 SQL 语句调用打包函数，除非通过在包规范中编码 `RESTRICT_REFERENCES` pragma 来声明其纯度级别。pragma 用于控制副作用，它告诉 PL/SQL 编译器拒绝打包函数对数据库表、公共打包变量或两者的读/写访问。违反 pragma 的 SQL 语句将导致编译错误。

* 解决方法：提高函数的纯度级别，或放宽 pragma 限制。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00455：cursor '%.\*s' cannot be used in dynamic SQL OPEN statement

* OceanBase 错误码：9686

* SQLSTATE：HY000

* 错误原因：动态打开具有返回类型的 REF 游标。然而，只有不带返回类型的REF游标才能被 `embeded` 动态 `OPEN` 语句打开。

* 解决方法：定义一个不带返回类型的 REF 游标，并在语句中使用它。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00457：expressions have to be of SQL types

* OceanBase 错误码：9620

* SQLSTATE：HY000

* 错误原因：`USING` 或 `dynamic RETURNING` 子句中存在错误类型的表达式。在 `USING` 或 `dynamic RETURNING` 子句中，表达式不能是非 SQL 类型，例如布尔、索引表和记录。

* 解决方法：将表达式类型更改为 SQL 类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00485：in exception handler, '%.\*s' must be an exception name

* OceanBase 错误码：5545

* SQLSTATE：42000

* 错误原因：未声明为异常的标识符出现在异常处理程序 `WHEN` 子句中。且 `WHEN` 子句中只有异常的名称有效。

* 解决方法：检查异常名称的拼写，确保正确声明了异常。

## PLS-00488：'%.\*s' must be a type

* OceanBase 错误码：9543

* SQLSTATE：HY000

* 错误原因：声明或表达式中的数据类型说明符未指定合法的类型。可能存在以下情况：

  * 可能未将 `％TYPE` 属性添加到声明中。如 `DECLARE my_sal emp.sal％TYPE;my_ename emp.ename;`，未申明 `％TYPE`。

  * 在声明常量或变量时，要自动提供列的数据类型，可使用 `％TYPE` 属性。

  * 在声明记录时，要自动提供行的数据类型，可使用 `％ROWTYPE` 属性。

* 解决方式：确保数据类型说明符指定合法的类型。必要时请使用 `％TYPE` 和 `％ROWTYPE` 属性。

## PLS-00491：numeric literal required

* OceanBase 错误码：9604

* SQLSTATE：HY000

* 错误原因：在需要数值常量的地方使用了常量或变量。例如，`my_ename VARCHAR2(max_len); instead of my_ename VARCHAR2(15);`，指定VARCHAR2变量的最大长度时，必须使用整数文字。

* 解决方式：将标识符替换为数值常量。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00492：variable or constant initialization may not refer to functions declared in the same package

* OceanBase 错误码：9655

* SQLSTATE：HY000

* 错误原因：如果一个包 `spec p` 声明了一个函数 `f`，那么该函数在任何情况下都不能使用同一个包规范中的变量声明。这是因为循环实例化问题：为了完全实例化包规范，必须初始化变量。要初始化变量，包体中的函数体代码必须为执行。这要求对包体进行实例化。然而，一揽子计划在包规范完全实例化之前，无法实例化包体。

* 解决方式：从变量初始化中删除对函数的引用。一种常用的技术是将变量初始化从变量声明（在包规范中）移动到包体初始化块。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00497：cannot mix between single row and multi-row (BULK) in INTO list

* OceanBase 错误码：9639

* SQLSTATE：HY000

* 错误原因：

  * 使用 `BULK` 语法（例如：`BULK COLLECT INTO`）检索数据时，输入 `INTO` 列表中的每个变量的类型必须是对应列类型的集合。

  * 不使用 `BULK` 语法，`INTO` 列表中的每个变量都必须是与相应列兼容的类型。

* 解决方式：更改 `INTO` 列表以便所有变量都具有正确的数据类型

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00503：RETURN value statement required for this return from function

* OceanBase 错误码：9634

* SQLSTATE：HY000

* 错误原因：在函数体中，使用了不包含表达式的返回语句。在过程中，`RETURN` 语句不包含表达式，因为该语句只是将控制权返回给调用方。但在函数中，`RETURN` 语句必须包含表达式，因为它的值被分配给函数标识符。

* 解决方式：在 `RETURN` 语句中添加一个表达式。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00520：MAP methods must be

declared without any parameters other than (optional) SELF

* OceanBase 错误码：9532

* SQLSTATE：HY000

* 错误原因：声明了 `MAP` 成员函数的参数。`MAP` 成员函数只能具有一个参数：默认的 `SELF` 参数。`MAP` 函数不可以申明为任何参数，由编译器添加 `SELF` 参数。

* 解决方法：删除 `MAP` 函数中的参数。

## PLS-00521：ORDER methods must be

declared with 1 (one) parameter in addition to (optional) SELF

* OceanBase 错误码：9538

* SQLSTATE：HY000

* 错误原因：声明了没有用户指定参数的 `ORDER` 函数。`ORDER` 函数具有两个参数，一个是由编译器添加的默认 `SELF` 参数。第二个参数由用户添加，并且必须与包含的对象类型相同。

* 解决方法：修改参数类型。

## PLS-00522：MAP methods must return a

scalar type

* OceanBase 错误码：9531

* SQLSTATE：HY000

* 错误原因：编写 `MAP` 成员函数时，返回的不是标量类型。

* 解决方法：重写 `MAP` 函数，使其返回标量类型。

## PLS-00523：ORDER methods must return

an INTEGER

* OceanBase 错误码：9533

* SQLSTATE：HY000

* 错误原因：`ORDER` 函数返回了除整数类型以外的类型。

* 解决方法：重写 `ORDER` 函数，使其返回整数类型。

## PLS-00524：The parameter type in an

ORDER method must be the containing object type

* OceanBase 错误码：9534

* SQLSTATE：HY000

* 错误原因：声明了没有用户指定参数的 `ORDER` 函数。`ORDER` 函数具有两个参数，一个是由编译器添加的默认 `SELF` 参数。第二个参数由用户添加，并且必须与包含的对象类型相同。

* 解决方法：修改参数类型。

## PLS-00525：Within SQL statements, only

equality comparisons of objects are allowed without a map or order function

* OceanBase 错误码：9535

* SQLSTATE：HY000

* 错误原因：没有提供 `MAP` 或 `ORDER` 函数以进行相关比较。如果未提供 `MAP` 或 `ORDER` 函数，则只能使用相等比较。

* 解决方法：提供对象的 `MAP` 或 `ORDER` 函数或将程序更改为仅使用相等比较。

## PLS-00526：A MAP or ORDER function is required for comparing objects in PL/

SQL

* OceanBase 错误码：9524

* SQLSTATE：HY000

* 错误原因：在 PL 代码中，对象的比较未定义 `MAP` 或者 `ORDER` 函数。

* 解决方法：定义 `MAP` 或 `ORDER` 函数并重试该操作。

## PLS-00527：MAP or ORDER functions

require a PRAGMA RESTRICT_REFERENCES specifying :WNDS,WNPS,RNPS,RNDS

* OceanBase 错误码：9536

* SQLSTATE：HY000

* 错误原因：

  * 未指定 `pragma restrict_references`。

  * 已指定 `pragma restrict_references` **，** 但 `pragma restrict_references` 中缺少了以下参数中的任意一种：`WNDS`、`WNPS` 、`RNPS` 或 `RNDS`。

* 解决方法：添加或更正 `pragma`，然后重试该操作。

## PLS-00528：The parameters to an ORDER

function must have IN mode

* OceanBase 错误码：9537

* SQLSTATE：HY000

* 错误原因：您已将 `ORDER` 函数的参数声明为 `OUT` 或 `IN OUT` 模式。

* 解决方法：更正参数声明为 `IN` 模式。

## PLS-00530：Illegal type used for object type attribute: '%.\*s'

* OceanBase 错误码：9651

* SQLSTATE：HY000

* 错误原因：对对象类型属性使用无效类型。

* 解决方法：仅对对象类型属性使用支持的类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00531：Unsupported type in a VARRAY or TABLE type: '%.\*s'

* OceanBase 错误码：9652

* SQLSTATE：HY000

* 错误原因：试图在 `VARRAY` 或 `TABLE type` 中使用不受支持的类型。

* 解决方法：仅在 `VARRAY` 或 `TABLE type` 中使用受支持的类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00537：A VARRAY must have a positive limit

* OceanBase 错误码：9611

* SQLSTATE：HY000

* 错误原因：使用非正限制声明了 VARRAY 类型，例如：`VARRAY（0）`。

* 解决方法：声明具有正限制的 VARRAY 类型，然后重试该操作。

## PLS-00538：subprogram or cursor '%.\*s'

is declared in an object type specification and must be defined in the object
type body

* OceanBase 错误码：9522

* SQLSTATE：HY000

* 错误原因：指定的子程序在对象类型的规范中声明，但未在对象类型主体中定义。

* 解决方法：在对象类型主体中定义子程序，或从规范中删除声明。

## PLS-00539：subprogram '%.\*s' is

declared in an object type body and must be defined in the object type specification

* OceanBase 错误码：9521

* SQLSTATE：HY000

* 错误原因：指定的子程序在对象类型的主体中声明，但未在对象类型的规范中定义。游标主体可以不定义。

* 解决方法：在对象类型的规范中定义子程序，或从主体中删除声明。

## PLS-00551：character set ANY_CS is only allowed on a subprogram parameter

* OceanBase 错误码：9608

* SQLSTATE：HY000

* 错误原因：字符集 `ANY_CS` 是在不允许的情况下指定的。

* 解决方法：更改或删除字符集规范。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00566：type name '%.\*s' cannot be constrained

* OceanBase 错误码：9607

* SQLSTATE：HY000

* 错误原因：lob、date、boolean、rowid 或 mlslabel 类型受长度规范约束。例如：`X BLOB（5）；`。

* 解决方法：移除约束。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00567：cannot pass NULL to a NOT NULL constrained formal parameter

* OceanBase 错误码：9673

* SQLSTATE：HY000

* 错误原因：将 `NULL` 传递给 `NOT NULL` 约束参数。

* 解决方法：传递一个非空表达式。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00572：improper constraint form used

* OceanBase 错误码：9606

* SQLSTATE：HY000

* 错误原因："number"类型不能有范围。用户定义的聚合类型和整数类型不能指定比例或精度。例如："`x number（5,3）`"是可以接受的，但"`x number range 1..10`"不允许。

* 解决方法：移除约束。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00586：a static method cannot declare a parameter named SELF

* OceanBase 错误码：9649

* SQLSTATE：HY000

* 错误原因：在声明静态方法时，将参数命名为 `SELF`。`SELF` 在方法中保留为参数名，用于保存应用该方法的对象实例。静态方法中不允许使用名为 `SELF` 的参数，因为静态方法不适用于特定的对象实例。

* 解决方法：更改声明中参数的名称。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00587：a static method cannot be

invoked on an instance value

* OceanBase 错误码：9527

* SQLSTATE：HY000

* 错误原因：尝试使用对象实例值而不是类型名作为方法调用名称的限定符，但是在调用静态方法时只能将类型名用作限定符。

* 解决方法：如果方法是静态的，则使用类型名而不是对象实例值来限定方法的名称。

## PLS-00589：no attributes found in object type '%.\*s'

* OceanBase 错误码：9650

* SQLSTATE：HY000

* 错误原因：定义了非 ADT 类型的表。

* 解决方法：类型的表格应仅为 ADT 类型

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00593：default value of parameter '%.\*s' in body must match that of spec

* OceanBase 错误码：9630

* SQLSTATE：HY000

* 错误原因：包体中包含的子程序体中参数的默认值初始化与相应包规范中相应子程序规范的默认值初始化不匹配。

* 解决方法：更改包体中参数的默认初始化以匹配 `spec` 的初始化。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00597：expression '%.\*s' in the INTO list is of wrong type

* OceanBase 错误码：9637

* SQLSTATE：HY000

* 错误原因：针对以下错误引发此异常：

  * `OPEN` 或 `RETURNING` 语句的 `INTO` 子句中的表达式既不是合法的 SQL 数据类型，也不是 PL/SQL 记录数据类型。

  * `OPEN` 或 `RETURNING` 语句的 `INTO` 子句中使用了一组记录。

  * 一条记录或一组记录用于 `BULK COLLECT INTO`。

* 解决方法：在 `INTO` 子句中使用数据类型正确的表达式。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00594：the SELF parameter can be declared only as IN or as IN OUT

* OceanBase 错误码：9530

* SQLSTATE：HY000

* 错误原因：`SELF` 参数被声明为 `OUT` 参数。

* 解决方法：将 `SELF` 参数声明为 `IN` 或 `IN OUT` 参数。

## PLS-00617：at least one result in the CASE expression must not be NULL

* OceanBase 错误码：9666

* SQLSTATE：HY000

* 错误原因：`CASE` 表达式中的所有结果都是文本 `NULL`。

* 解决方法：将 `CASE` 表达式中的至少一个结果更改为非 `NULL`。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00619：the first operand in the NULLIF expression must not be NULL

* OceanBase 错误码：9647

* SQLSTATE：HY000

* 错误原因：`NULLIF` 表达式中的第一个操作数是文本 `NULL`。

* 解决方法：将 `NULLIF` 表达式中的第一个操作数更改为 `non-NULL`。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00621：at least one operand in the COALESCE expression must not be NULL

* OceanBase 错误码：9648

* SQLSTATE：HY000

* 错误原因：合并表达式中的所有操作数都是文本 `NULL`。

* 解决方法：将合并表达式中的至少一个操作数更改为 `non-NULL`。

## PLS-00629：PIPE statement cannot be used in non-pipelined functions

* OceanBase 错误码：9623

* SQLSTATE：HY000

* 错误原因：在非流水线函数中使用了 `PIPE` 语句。

* 解决方法：仅在流水线函数中使用 `PIPE` 语句。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00630：pipelined functions must have a supported collection return type

* OceanBase 错误码：9601

* SQLSTATE：HY000

* 错误原因：使用不支持的返回类型指定了流水线函数。不支持如下集合类型作为流水线函数的返回类型：

  * 非集合。

  * PL/SQL 表。

  * 关联数组。

  * PL/SQL 类型的集合：rowid、mlslabel，long，long raw，boolean，binary_integer，pls_integer，string 和 urowid。
  
* 解决方法：将支持的集合类型指定为流水线函数返回类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00633：RETURN statement in a pipelined function cannot contain an expression

* OceanBase 错误码：9635

* SQLSTATE：HY000

* 错误原因：管道函数中的 `RETURN` 语句包含表达式，这是不允许的。流水线函数必须使用 `PIPE` 语句将值发回调用方。

* 解决方法：从 `RETURN` 语句中删除表达式，并使用 `PIPE` 语句返回值。否则，将函数转换为非流水线函数。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00642：local collection types not allowed in SQL statements

* OceanBase 错误码：9589

* SQLSTATE：HY000

* 错误原因：SQL 语句中使用了本地定义（即非模式级别）的集合类型。该类型必须在架构中定义，才能在 SQL 语句中接受。

* 解决方法：在模式中定义集合类型，而不是在 PL/SQL 子程序中。

## PLS-00652：incorrect number of arguments for aggregate function

* OceanBase 错误码：9633

* SQLSTATE：HY000

* 错误原因：创建具有 `0` 个参数或超过 `999` 个参数的聚合函数。

* 解决方法：不要创建参数为 `0` 或超过 `999` 的聚合函数。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00655：only functions can be declared as PIPELINED

* OceanBase 错误码：9600

* SQLSTATE：HY000

* 错误原因：PIPELINED 类型只支持在 FUNCTION 中定义。

* 解决方式：将语句类型修改为 FUNCTION，或者去掉 PIPELINED 的使用。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00657：Implementation restriction: bulk SQL with associative arrays with VARCHAR2 key is not supported

* OceanBase 错误码：9638

* SQLSTATE：HY000

* 错误原因：关联数组类型的变量或表达式用作批量 SQL 绑定或定义。

* 解决方法：使用大容量 SQL 支持的 collection 类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00658：constructor method name must match type name

* OceanBase 错误码：9528

* SQLSTATE：HY000

* 错误原因：尝试使用对象实例值而不是类型名作为方法调用名称的限定符，但是在调用静态方法时只能将类型名用作限定符。

* 解决方法：如果方法是静态的，则使用类型名而不是对象实例值来限定方法的名称。

## PLS-00659：constructor method must return SELF AS RESULT

* OceanBase 错误码：9646

* SQLSTATE：HY000

* 错误原因：构造函数方法的 `return`子句没有指定 `SELF` 作为结果。

* 解决方式：将 `return` 子句更改为包含 `return SELF` 作为结果。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00660：SELF parameter of constructor method must be IN OUT

* OceanBase 错误码：9645

* SQLSTATE：HY000

* 错误原因：构造函数的 `SELF` 参数的模式不是 `IN OUT`。

* 解决方式：将 `SELF` 参数的模式更改为 `IN OUT`。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00661：RETURN statement in a CONSTRUCTOR cannot include an expression

* OceanBase 错误码：9541

* SQLSTATE：HY000

* 错误原因：在 `CONSTRUCTOR` 主体的 `RETURN` 语句中存在表达式。

* 解决方式：从 `RETURN` 语句中删除该表达式。

## PLS-00667：Element type of associative array should be pls_integer or binary_integer

* OceanBase 错误码：9617

* SQLSTATE：HY000

* 错误原因：指定元素类型不是 `pls_integer` 或 `binary_integer` 的索引集合。

* 解决方式：将索引集合变量类型更改为元素类型为 `pls_integer` 或 `binary_integer` 的关联数组。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00668：Type of expression should be a collection type

* OceanBase 错误码：9616

* SQLSTATE：HY000

* 错误原因：在类型不是集合类型的子句的索引或值之后指定表达式。

* 解决方式：将索引集合表达式类型更改为有效的集合类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00674：references to fields of BULK In-BIND table of records or objects must have the form A(I).F

* OceanBase 错误码：9613

* SQLSTATE：HY000

* 错误原因：表单 table(bulk_index).field 是运行时唯一支持的字段选择。

* 解决方式：使用 `FOR` 循环代替 `FORALL DML` 语句（`MERGE/INSERT/DELETE/UPDATE`），或者修改引用以适应允许的形式。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00675：invalid section for this type of Compound Trigger

* OceanBase 错误码：9698

* SQLSTATE：HY000

* 错误原因：组合触发器的触发事件类型需要和触发器基于的对象保持一致。

* 解决方式：如果组合触发器基于视图创建，只能定义 Instead of 触发事件，如果基于表定义，只能定义 Instead of 触发事件以外的事件。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00676：duplicate Compound Triggers section

* OceanBase 错误码：9699

* SQLSTATE：HY000

* 错误原因：每个 Compound 触发器部分最多只能在 Compound 触发器的主体中出现一次。

* 解决方式：删除有问题的部分。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00701：illegal ORACLE error number %.\*s for PRAGMA EXCEPTION_INIT

* OceanBase 错误码：9629

* SQLSTATE：HY000

* 错误原因：传递给 `EXCEPTION_INIT` pragma 的错误码编号超出范围。错误号必须在 `1-9999` 范围内（不包括 `100`）或 `20000-20999` 范围内的错误码编号用于用户定义的错误。

* 解决方式：请使用有效的错误码编号。

## PLS-00702：second argument to PRAGMA EXCEPTION_INIT must be a numeric literal

* OceanBase 错误码：9676

* SQLSTATE：HY000

* 错误原因：传递给 `EXCEPTION_INIT` pragma 的第二个参数不是数值文字（如：变量）。第二个参数必须在 `1-9999`（不包括 `100`）范围内，`20000-20999` 范围内的错误码编号用于用户定义的错误。

* 解决方式：用有效的错误号替换第二个参数。

## PLS-00708：Pragma %.\*s must be declared in a package specification

* OceanBase 错误码：9603

* SQLSTATE：HY000

* 错误原因：`pragma` 未按要求在包规范中声明。例如，`RESTRICT_REFERENCES` 必须在包规范中声明。

* 解决方式：删除或重新定位放错位置的 pragma。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00709：pragma %.\*s must be declared in package specification and body

* OceanBase 错误码：9632

* SQLSTATE：HY000

* 错误原因：命名的 `pragma` 在包规范中声明，但不在相应的包体中声明，反之亦然，也不在包体中声明。

* 解决方式：将 `pragma` 添加到包声明中没有 `pragma` 的部分。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00710：Pragma string cannot be specified here", "Pragma %s cannot be specified here

* OceanBase 错误码：9509

* SQLSTATE：HY000

* 错误原因：此处不能指定 `AUTONOMOUS_TRANSACTION` 程序。

* 解决方法：检查程序名称是否拼写正确。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00711：PRAGMA string cannot be declared twice", "PRAGMA %.\*s cannot be declared twice

* OceanBase 错误码：9621

* SQLSTATE：HY000

* 错误原因：`PRAGMA` 在同一块中声明了两次。

* 解决方式：删除 `PRAGMA` 的重复声明。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00712：illegal option for subprogram %.\*s

* OceanBase 错误码：9626

* SQLSTATE：HY000

* 错误原因：只有顶级子程序或包或类型规范中的子程序声明才允许启用"DETERMINISTIC"或 "PARALLEL_ENABLE"选项。例如，如果在包或类型包体中使用选项，则会引发此错误。

* 解决方式：删除该选项。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00742：field %.\*s is not yet denotable

* OceanBase 错误码：9669

* SQLSTATE：HY000

* 错误原因：声明记录的字段时，一个字段用于初始化另一个字段，如：键入 `my_rec IS record（f1 varchar2（10），f2 varchar2（10）：=f1）；` 第一个字段在运行时之前没有值，因此不能用于初始化另一个字段。

* 解决方式：删除非法的字段引用。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00904：insufficient privilege to access object string

* OceanBase 错误码：9625

* SQLSTATE：HY000

* 错误原因：在没有所需权限的情况下对数据库对象进行操作。例如，如果试图更新仅授予 `SELECT` 权限的表，或者数据库对象的 `ACCESS BY` 子句禁止尝试编译，则会发生此错误。

* 解决方式：请 DBA 执行操作或授予您所需的权限。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00905：object '%.\*s' is invalid

* OceanBase 错误码：9548

* SQLSTATE：HY000

* 错误原因：引用了无效的软件包规范或子程序。如果自从上次编译后，软件包规范或子程序的源代码或它引用的任何数据库对象已被丢弃，替换或更改，则该软件包或子程序无效。

* 解决方法：找到软件包规范或子程序无效的原因，并确保能重新正确的编译该软件包规范或子程序。

## PLS-00990：Index Tables of Cursor Variables are disallowed

* OceanBase 错误码：9672

* SQLSTATE：HY000

* 错误原因：cursor 不支持 作为 array 类型的项。

* 解决方法：检查 array 类型的项的类型，避免使用 cursor 类型。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>

## PLS-00994：Cursor Variables cannot be

declared as part of a package

* OceanBase 错误码：9516

* SQLSTATE：HY000

* 错误原因：试图在程序包规范中声明一个游标变量，这是不允许的。尽管可以在 PL 块、子程序或程序包中可以定义 `REF CURSOR` 类型，但是游标变量只能在块或子程序中声明。

* 解决方法：将游标变量声明移到 PL 块或子程序中

## PLS-00999：implementation restriction (may be temporary) %s

* OceanBase 错误码：9624

* SQLSTATE：HY000

* 错误原因：

  * RESULT_CACHE 不支持含有 OUT 和 INOUT 参数的 FUNCTION

  * RESULT_CACHE 不支持 RETURN 类型或者 IN 参数类型包含以下类型的 FUNCTION：

    * BLOB

    * CLOB

    * NCLOB

    * REFCURSOR

    * Collection

    * Object

    * 含有上述类型的 Record or PL/SQL collection 类型

  * RESULT_CACHE 不支持 匿名块中的 FUNCTION

  * RESULT_CACHE 不支持 PIPELINE FUNCTION 和 NESTED FUNCTION

* 解决方法：去掉在上述不支持情况中使用的 RESULT_CACHE

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>该错误码从 V4.0.0 版本开始引入。</p>
</main>
