| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# 向量索引

OceanBase 支持 HNSW 索引，支持 L2 和 IP 距离作为索引距离算法。HNSW 索引是一种内存索引，需要完整载入内存，支持 DML 和实时查询。

## 向量索引查询

向量索引查询是一种近似最近邻查询，并不保证 100% 的结果正确。相应的向量查询准确率的指标是召回率，例如在查 10 个最近邻时，如果可以稳定返回 9 个正确的结果，那么召回率就是 90%。召回率说明如下：

* 召回率受构建参数和查询参数的影响。

* 构建参数在建索引时指定，之后不可修改。

* 查询参数在建索引时指定，之后不可修改，但可通过 session 变量 `ob_hnsw_ef_search` 设置。如果设置了 `ob_hnsw_ef_search`，会优先使用它的值。具体设置方式请参见[ob_hnsw_ef_search](../../700.reference/800.configuration-items-and-system-variables/200.system-variable/400.session-system-variable/2200.ob_hnsw_ef_search.md)。

### 查询语法

```sql
SELECT ... FROM $table_name ORDER BY $distance_function($column_name, $vector_expr) [APPROXIMATE|APPROX] LIMIT|OFFSET $num;
```

使用说明如下：

* 目前仅支持 `ORDER BY` 后跟随一个向量条件的情况，否则会报错 `ERROR 1235 (0A000): Multi order by item when using vector index is not supported`。

* 查询包含 `WHERE` 条件时，不论条件是否为其他索引列，只要满足上述语法都会调用向量索引，`WHERE` 条件作为向量索引查询后的过滤条件。

* 必须带有 `APPROXIMATE`/`APPROX` 关键字，查询计划才会选择向量索引路径。

* 支持 `l2_distance`，`inner_product`，`negative_inner_product` 作为 `ORDER BY` 指定距离函数，其中 `l2_distance`，`negative_inner_product` 选择索引计划，`inner_product` 不选择索引计划。

* 除了 `l2_distance`，`inner_product`，`negative_inner_product` 以外的距离函数，使用 `APPROXIMATE`/`APPROX` 选择向量索引路径时会报错 `ERROR 1235 (0A000): Using vector index without vector_sort_expr is not supported`。

* `LIMIT`/`OFFSET` 的取值范围为 `(0,  16384]`。

### 索引创建及查询示例

```shell
## 创建测试表
OceanBase(root@oceanbase)>CREATE TABLE t1(c1 INT, c0 INT, c2 VECTOR(10), c3 VECTOR(10), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw, lib=vsag),  VECTOR INDEX idx2(c3) WITH (distance=l2, type=hnsw, lib=vsag));

## 写入测试数据
OceanBase(root@oceanbase)>INSERT INTO t1 VALUES(1, 1,'[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]', '[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

OceanBase(root@oceanbase)>INSERT INTO t1 VALUES(2, 2, '[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.226980,0.579658,0.933939]', '[0.213846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

OceanBase(root@oceanbase)>INSERT INTO t1 VALUES(3, 3, '[0.327936,0.048756,0.084670,0.389642,0.970982,0.370915,0.181664,0.940780,0.013905,0.628127]', '[0.223846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

## 使用近似最近邻查询
OceanBase(root@oceanbase)>SELECT * FROM t1 ORDER BY l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE LIMIT 1;
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
| c1 | c0   | c2                                                                                        | c3                                                                                         |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
|  3 |    3 | [0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127] | [0.223846,0.205289,0.880265,0.82434,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833] |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
1 row in set
```

### 索引维护

增量数据过多的情况下，查询性能会下降。为减小增量数据表的数据量，OceanBase 引入了 DBMS_VECTOR 对向量索引进行维护。

#### 增量刷新

如果建立索引后写入数据较多，建议使用增量刷新。

语法如下：

```shell
  PROCEDURE refresh_index(
    IN     idx_name               VARCHAR(65535),                 ---- 索引名
    IN     table_name             VARCHAR(65535),                 ---- 表名
    IN     idx_vector_col         VARCHAR(65535) DEFAULT NULL,    ---- 向量列名
    IN     refresh_threshold      INT DEFAULT 10000,              ---- 增量数据数量
    IN     refresh_type           VARCHAR(65535) DEFAULT NULL);   ---- FAST
```

#### 全量刷新

如果建立索引后更新或删除数据较多，建议使用全量刷新。

语法如下：

```shell
  PROCEDURE rebuild_index(
    IN     idx_name                VARCHAR(65535),                    ---- 索引名
    IN     table_name              VARCHAR(65535),                    ---- 表名
    IN     idx_vector_col          VARCHAR(65535) DEFAULT NULL,       ---- 向量列名
    IN     delta_rate_threshold    FLOAT DEFAULT 0.2,                 ---- 增量数据的比例
    IN     idx_organization        VARCHAR(65535) DEFAULT NULL,       ---- 索引类型
    IN     idx_distance_metrics    VARCHAR(65535) DEFAULT 'EUCLIDEAN',---- 距离类型
    IN     idx_parameters          LONGTEXT DEFAULT NULL,             ---- 索引参数
    IN     idx_parallel_creation   INT DEFAULT 1);                    ---- 并行构建索引的并行度，预留，仅语法支持
```

#### 索引维护示例

```sql
CREATE TABLE vector_index_test(c1 INT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw, lib=vsag));
INSERT INTO vector_index_test VALUES(1, '[0.203846,0.205289,0.880265]');
INSERT INTO vector_index_test VALUES(2, '[0.484526,0.669954,0.986755]');
INSERT INTO vector_index_test VALUES(3, '[0.327936,0.048756,0.084670]');
INSERT INTO vector_index_test VALUES(4, '[0.148869,0.878546,0.028024]');
INSERT INTO vector_index_test VALUES(5, '[0.334970,0.857377,0.886132]');
INSERT INTO vector_index_test VALUES(6, '[0.117582,0.302352,0.471198]');
INSERT INTO vector_index_test VALUES(7, '[0.551185,0.231134,0.075354]');
INSERT INTO vector_index_test VALUES(8, '[0.185221,0.315131,0.558301]');
INSERT INTO vector_index_test VALUES(9, '[0.928764,0.254038,0.272721]');

-- 触发增量更新
call dbms_vector.refresh_index('idx1', 'vector_index_test', 'c2', 1, 'FAST');

-- 触发全量更新
call dbms_vector.rebuild_index('idx1','t1','c2');
```

## 相关文档

* [向量函数](200.ob-vector-function.md)